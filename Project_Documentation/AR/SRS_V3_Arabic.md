# مواصفات متطلبات النظام (SRS) الإصدار 3.0
## دستور النظام - الوثيقة الشاملة

**التحكم في الوثيقة**
- الإصدار: 3.0
- الحالة: الوثيقة الدستورية للنظام
- التصنيف: وثيقة معمارية استراتيجية
- نطاق الامتثال: ISO 27001, ISO 9001, الأنظمة العقارية السعودية
- الجمهور المستهدف: مدير تقنية المعلومات، مدير التقنية، المستثمرون، مسؤولو الامتثال، فرق التطوير

**تاريخ الإصدار:** 19 نوفمبر 2025

---

# **الجزء الأول: النظرة التنفيذية والاستثمارية**

## 1. الملخص التنفيذي والرؤية الاستراتيجية

### 1.1 دراسة الجدوى وعرض القيمة (Business Case & Value Proposition)

#### 1.1.1 الفرصة السوقية في قطاع التقنية العقارية السعودية

**النظرية (Theory):**

يشهد القطاع العقاري السعودي تحولاً رقمياً غير مسبوق مدفوعاً بعدة عوامل استراتيجية:

1. **رؤية المملكة 2030:** التحول الرقمي كركيزة أساسية للاقتصاد الوطني
2. **النمو السكاني:** زيادة متوقعة في عدد السكان إلى 40 مليون بحلول 2030
3. **التحول التنظيمي:** إلزامية توثيق العقود عبر منصة "إيجار" (Ejar Platform)
4. **الطلب المتزايد:** نقص حاد في الحلول التقنية المتكاملة للمكاتب العقارية الصغيرة والمتوسطة

**حجم السوق القابل للاستهداف (Total Addressable Market - TAM):**

- **عدد المكاتب العقارية المرخصة في المملكة:** ~12,000 مكتب (وفقاً لبيانات الهيئة العامة للعقار - RERA)
- **متوسط الاشتراك السنوي المتوقع:** 12,000 ريال سعودي
- **إجمالي السوق القابل للاستهداف (TAM):** 144 مليون ريال سعودي سنوياً
- **السوق القابل للخدمة (Servicable Addressable Market - SAM):** 30% = 43.2 مليون ريال سعودي (المكاتب التي تبحث عن حلول رقمية)
- **السوق القابل للتحقيق (Servicable Obtainable Market - SOM):** 10% في السنة الثالثة = 14.4 مليون ريال سعودي

**المحفزات الرئيسية للنمو:**

1. **الفجوة التقنية الحالية:** 
   - 85% من المكاتب العقارية تعتمد على Excel وأساليب يدوية
   - عدم وجود منصة عربية متكاملة تلبي المتطلبات المحلية
   
2. **الإلزامية التنظيمية:**
   - إلزامية التوثيق الإلكتروني للعقود (Ejar)
   - متطلبات حماية البيانات الشخصية (PDPL)
   - معايير هيئة الزكاة والضريبة والجمارك (ZATCA) لإصدار الفواتير الإلكترونية

3. **التكلفة التشغيلية:**
   - المكاتب العقارية تفقد 15-20% من إيراداتها بسبب سوء الإدارة
   - متوسط تكلفة الموظف الإضافي: 60,000 ريال سنوياً (يمكن توفيره عبر الأتمتة)

**المثال (Example):**

**دراسة حالة افتراضية - مكتب "الرائد العقاري":**
- **الحجم:** 8 موظفين، يدير 150 عقار، 300 عميل نشط
- **قبل النظام:**
  - 25 ساعة/أسبوع تُهدر في العمل اليدوي (إدخال بيانات، تقارير Excel)
  - 12% من العقود تتأخر في التوثيق (غرامات من إيجار)
  - عدم وجود رؤى تحليلية لاتخاذ القرار
  
- **بعد النظام:**
  - توفير 20 ساعة/أسبوع (80% كفاءة أعلى)
  - توثيق فوري للعقود (0% تأخير)
  - زيادة معدل إتمام الصفقات بنسبة 35% بفضل البيانات التحليلية
  - **ROI محقق:** 450% في السنة الأولى

**الأداة المساعدة (Aid):**

**مصفوفة المقارنة التنافسية:**

| المعيار | الحلول التقليدية (Excel + WhatsApp) | المنافسون الدوليون (Salesforce, Zoho) | **نظامنا** |
|---------|--------------------------------------|----------------------------------------|------------|
| **دعم اللغة العربية (RTL)** | محدود | ضعيف | كامل ✓ |
| **التكامل مع إيجار (Ejar)** | يدوي | غير متوفر | تلقائي ✓ |
| **الامتثال لـ PDPL** | غير متوفر | جزئي | كامل ✓ |
| **Multi-Tenancy (عزل البيانات)** | غير متوفر | متوفر | متوفر ✓ |
| **التحليلات المتقدمة (BI)** | غير متوفر | متوفر (تكلفة إضافية) | مدمج ✓ |
| **WhatsApp Integration (2FA + إشعارات)** | يدوي | غير متوفر | مدمج ✓ |
| **التكلفة السنوية** | مجاني (لكن تكلفة الوقت عالية) | $1,500-$5,000 (غير مخصص) | **600-1,800 ريال (تسعير تنافسي)** |
| **الدعم الفني بالعربية** | غير متوفر | محدود | 24/7 ✓ |

---

#### 1.1.2 استراتيجية التمايز التنافسي

**العوامل الفارقة الأساسية (Core Differentiators):**

##### 1. **ذكاء السوق والتحليلات التنبؤية (Market Intelligence & Predictive Analytics)**

**التكامل الاستراتيجي مع الملاحظة رقم 7 (User Note #7):**

نظامنا يتجاوز مجرد إدارة العقارات ليصبح **منصة ذكاء أعمال شاملة (End-to-End Business Intelligence Platform)** توفر رؤى قابلة للتنفيذ لثلاث شرائح رئيسية:

**أ. رؤى مخصصة للملاك والمؤجرين:**

**البيانات التحليلية المتقدمة:**
- **تحليل السجل الإيجاري التاريخي:** متوسط الإيجار، توقيتات الزيادة، معدل الشغور (Vacancy Rate)
- **تتبع تكاليف الصيانة:** تحليل المصروفات الدورية والطارئة لتحديد ميزانية مستقبلية دقيقة
- **مؤشر الاحتفاظ بالمستأجرين (Tenant Retention Rate):** قياس رضا المستأجرين وجودة العقار
- **تقييم الأداء المالي:** مقارنة عائدات الإيجار الفعلية بالسوق (Rental Yield Analysis)
- **تحليل استهلاك الخدمات:** كهرباء، ماء (مؤشرات الكفاءة)

**الرؤى القابلة للتنفيذ (Actionable Insights):**
```
مثال: "عقارك في حي النرجس يحقق إيجار 45,000 ريال/سنة، بينما متوسط السوق 52,000 ريال. 
توصية: زيادة الإيجار بنسبة 15% مع إضافة ميزة مواقف السيارات المغطاة."
```

**ب. رؤى مخصصة للمستأجرين:**

**تحليل السوق من منظور المستأجر:**
- **مؤشر أسعار الإيجارات (Rental Index):** مقارنة تكلفة المعيشة بين الأحياء المختلفة
- **تحليل التفضيلات الديموغرافية:** طبيعة السكان في كل حي (عائلات، أفراد، مهنيون)
- **مؤشر جودة الحي (Neighborhood Score):**
  - **Walkability Score:** سهولة الوصول للخدمات اليومية
  - **Safety Score:** معدلات الأمان بناءً على البيانات العامة
  - **Connectivity Score:** جودة شبكات الإنترنت والاتصالات
- **تقييمات المباني:** استبيانات رضا المستأجرين السابقين
- **مؤشر "صديق للحيوانات الأليفة" (Pet-Friendly Index)**

**الرؤى القابلة للتنفيذ:**
```
مثال: "حي الياسمين يوفر أفضل قيمة مقابل السعر ضمن ميزانيتك (35,000 ريال/سنة) مع 
Walkability Score = 8.5/10 وقرب من مدارس دولية (3 مدارس ضمن نطاق 2 كم)."
```

**ج. رؤى مخصصة للمستثمرين العقاريين:**

**تحليل السوق الكلي والجزئي:**
- **تحليل حجم الصفقات:** بيع وشراء في مناطق مختلفة
- **متوسط سعر المتر المربع:** للأراضي والعقارات السكنية والتجارية
- **مؤشرات النمو السكاني والاقتصادي:** بيانات مدن وأحياء معينة
- **تحليل العائد الإيجاري الصافي (Net Rental Yield):** مقارنة بين المناطق
- **تأثير المشاريع الضخمة:** (مشاريع رؤية 2030) على أسعار العقارات المحيطة
- **مؤشر التحسين الحضري (Gentrification Index):** رصد افتتاح مقاهي فاخرة، متاجر جديدة كمؤشر على ارتفاع القيمة

**الرؤى التنبؤية (Predictive Insights):**
```
مثال: "منطقة العليا تظهر نمو 12% سنوياً في أسعار العقارات بسبب مشروع مترو الرياض 
(المحطة تبعد 500م). توقعات العائد على الاستثمار (ROI) خلال 5 سنوات: 65%."
```

**د. تحليلات مبتكرة ومستقبلية:**

- **تحليل المشاعر على وسائل التواصل (Social Media Sentiment Analysis):** رصد ما يقوله الناس عن الأحياء
- **مؤشر الطلب على العقارات المستدامة (Green Building Demand)**
- **نمذجة التنبؤ بقيمة الإيجار (Rental Value Prediction):** باستخدام AI/ML
- **تحليل الفجوة في السوق (Market Gap Analysis):** أنواع العقارات ذات الطلب العالي والمعروض القليل
- **خريطة الأصول غير المستغلة (Underutilized Assets Map):** فرص إعادة تطوير

**التقنيات المستخدمة:**
- **Data Warehousing:** لتخزين البيانات التاريخية
- **Machine Learning Models:** للتنبؤ بالأسعار (TensorFlow/PyTorch - Phase 3)
- **Natural Language Processing (NLP):** لتحليل المشاعر
- **Geospatial Analysis:** لتحليل المواقع الجغرافية (PostGIS)

---

##### 2. **البنية التحتية للأمان والامتثال (Security & Compliance by Design)**

**الميزات الفارقة:**

**أ. الامتثال الكامل للأنظمة السعودية:**
- **PDPL (Personal Data Protection Law):** 
  - إدارة موافقات البيانات (Consent Management)
  - حقوق أصحاب البيانات (الوصول، التصحيح، الحذف)
  - تشفير شامل للبيانات الحساسة
- **RERA Integration:** تكامل تلقائي مع منصة إيجار
- **ZATCA E-Invoicing:** توليد فواتير إلكترونية متوافقة
- **Data Sovereignty:** خوادم محلية (Saudi Cloud Providers)

**ب. معايير أمان عالمية:**
- **ISO 27001 Compliant:** نظام إدارة أمن المعلومات
- **JWT + Refresh Token Architecture:** جلسات آمنة مع تحديث تلقائي (حل الملاحظة #3)
- **Two-Factor Authentication (2FA):** عبر WhatsApp Business API (حل الملاحظة #19)
- **Role-Based Access Control (RBAC):** صلاحيات حبيبية على مستوى الصف والعمود (حل الملاحظة #8)
- **Multi-Tenancy Isolation:** عزل تام للبيانات بين المكاتب العقارية

---

##### 3. **تجربة مستخدم عربية أصيلة (Native Arabic UX)**

**التصميم المتكامل:**
- **Right-to-Left (RTL) Support:** ليس مجرد ترجمة، بل تصميم أصيل
- **واجهات مزدوجة اللغة:** عربي/إنجليزي بتبديل سلس
- **مصطلحات عقارية محلية:** مخطط، شقة، فيلا، دور، استراحة (عوضاً عن المصطلحات الأجنبية)
- **التقويم الهجري والميلادي:** دعم كامل للتواريخ
- **الدعم الفني بالعربية:** 24/7

---

##### 4. **نموذج التسعير المرن والشفاف**

**الاشتراكات المتدرجة (Subscription Tiers):**

| الباقة | المستخدمون | العقارات | المميزات | السعر الشهري | السعر السنوي |
|--------|------------|----------|----------|--------------|--------------|
| **Starter** | حتى 3 | حتى 50 | الأساسيات (عقارات، عملاء، عقود) | 200 ريال | **2,000 ريال** (خصم 17%) |
| **Professional** | حتى 10 | حتى 200 | + تحليلات متقدمة + تكامل إيجار | 500 ريال | **5,000 ريال** (خصم 17%) |
| **Enterprise** | غير محدود | غير محدود | + AI Insights + White-Label | 1,500 ريال | **15,000 ريال** (خصم 17%) |
| **Custom** | حسب الطلب | حسب الطلب | حلول مخصصة للشركات الكبرى | حسب الطلب | حسب الطلب |

**مصادر الإيرادات الإضافية (Additional Revenue Streams):**
1. **Transaction Fees:** عمولة 0.5% على المدفوعات الإلكترونية (اختياري)
2. **Premium Analytics Reports:** تقارير سوقية شهرية (500 ريال/تقرير)
3. **API Access for Developers:** للتكاملات الخارجية (حسب الاستخدام)
4. **White-Label Solutions:** للمطورين العقاريين الكبار (من 50,000 ريال/سنة)

---

#### 1.1.3 إجمالي السوق القابل للاستهداف (Total Addressable Market - TAM)

**تحليل TAM-SAM-SOM:**

```
┌─────────────────────────────────────────────────┐
│  TAM = 144 مليون ريال (كامل السوق السعودي)     │
│  ┌───────────────────────────────────────────┐  │
│  │  SAM = 43.2 مليون ريال (30% يبحثون عن    │  │
│  │         حلول رقمية)                       │  │
│  │  ┌─────────────────────────────────────┐  │  │
│  │  │  SOM = 14.4 مليون ريال (10% حصة    │  │  │
│  │  │         سوقية متوقعة في السنة 3)    │  │  │
│  │  └─────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
```

**توسعات مستقبلية (Geographic Expansion):**
- **Year 4-5:** دول الخليج (الإمارات، الكويت، البحرين، عمان، قطر)
- **TAM الإقليمي:** 400 مليون ريال إضافية

---

#### 1.1.4 مصادر الإيرادات ونموذج تحقيق الربح

##### 1.1.4.1 الاشتراكات المتدرجة (Office-Based Subscriptions)

**النموذج الأساسي:**
- **نموذج SaaS (Software as a Service):** دفع شهري/سنوي
- **لا تكاليف مقدمة:** بدون رسوم إعداد (Setup Fees)
- **فترة تجريبية:** 14 يوم مجاناً (بطاقة ائتمان غير مطلوبة)
- **إلغاء في أي وقت:** بدون عقود طويلة الأجل

**توقعات الاشتراكات (Year 1-3):**

| السنة | عدد المكاتب | متوسط الإيراد/مكتب/سنة | إجمالي الإيرادات |
|------|-------------|------------------------|------------------|
| Year 1 | 150 | 3,600 ريال | 540,000 ريال |
| Year 2 | 500 | 4,200 ريال | 2,100,000 ريال |
| Year 3 | 1,200 | 4,500 ريال | 5,400,000 ريال |

**معدل النمو المركب (CAGR):** 225% على مدى 3 سنوات

---

##### 1.1.4.2 رسوم المعاملات ونموذج العمولة (Transaction Fees)

**الإيرادات الثانوية:**
- **رسوم معالجة المدفوعات:** 0.5% من قيمة المعاملة (اختياري)
- **متوسط قيمة المعاملة:** 30,000 ريال (إيجار سنوي)
- **متوسط المعاملات/مكتب/سنة:** 50 معاملة
- **الإيرادات المتوقعة (Year 3):** 1,200 مكتب × 50 معاملة × 30,000 ريال × 0.5% = **9,000,000 ريال**

---

##### 1.1.4.3 خدمات التحليلات المتقدمة والـ BI المميزة

**النموذج:**
- **تقارير سوقية شهرية:** 500 ريال/تقرير
- **لوحات معلومات مخصصة (Custom Dashboards):** 2,000 ريال/لوحة (إعداد لمرة واحدة)
- **الاستشارات التحليلية:** 300 ريال/ساعة

**الإيرادات المتوقعة (Year 3):** 600,000 ريال

---

##### 1.1.4.4 حلول White-Label للشركات الكبرى

**النموذج:**
- **إعداد مبدئي:** 50,000 ريال
- **اشتراك سنوي:** 100,000 ريال
- **الجمهور المستهدف:** شركات التطوير العقاري (5-10 شركات في Year 3)

**الإيرادات المتوقعة (Year 3):** 750,000 ريال

---

**إجمالي الإيرادات المتوقعة (Year 3):**
```
الاشتراكات:           5,400,000 ريال
رسوم المعاملات:       9,000,000 ريال
التحليلات المميزة:      600,000 ريال
White-Label:           750,000 ريال
─────────────────────────────────────
الإجمالي:           15,750,000 ريال
```

---

### 1.2 إطار العائد على الاستثمار (ROI Framework)

#### 1.2.1 التوقعات المالية (أفق 3 سنوات)

**جدول التدفقات النقدية المتوقعة:**

| البند | Year 1 | Year 2 | Year 3 |
|-------|--------|--------|--------|
| **الإيرادات** |
| الاشتراكات | 540,000 | 2,100,000 | 5,400,000 |
| رسوم المعاملات | 225,000 | 1,500,000 | 9,000,000 |
| خدمات إضافية | 50,000 | 300,000 | 1,350,000 |
| **إجمالي الإيرادات** | **815,000** | **3,900,000** | **15,750,000** |
| **التكاليف** |
| تطوير المنتج | 400,000 | 300,000 | 200,000 |
| البنية التحتية (AWS/Supabase) | 60,000 | 150,000 | 400,000 |
| التسويق والمبيعات | 200,000 | 600,000 | 1,500,000 |
| الرواتب (الفريق التقني) | 600,000 | 1,200,000 | 2,400,000 |
| الدعم الفني | 100,000 | 250,000 | 600,000 |
| المصروفات الإدارية | 80,000 | 150,000 | 300,000 |
| **إجمالي التكاليف** | **1,440,000** | **2,650,000** | **5,400,000** |
| **صافي الربح/الخسارة** | **(625,000)** | **1,250,000** | **10,350,000** |
| **هامش الربح** | -77% | 32% | **66%** |

**الملاحظات الاستراتيجية:**
- **Year 1:** استثمار في التطوير (خسارة متوقعة)
- **Year 2:** الوصول للربحية (Break-Even في Q3)
- **Year 3:** نمو متسارع مع هامش ربح مرتفع

---

#### 1.2.2 تحليل التكلفة والعائد (Cost-Benefit Analysis)

**التكلفة الإجمالية للملكية (Total Cost of Ownership - TCO) للمستثمر:**

**الاستثمار المبدئي المطلوب:**
- **المرحلة التأسيسية (Year 0):** 1,200,000 ريال
  - تطوير MVP (Minimum Viable Product): 400,000 ريال
  - التسويق الأولي: 300,000 ريال
  - التراخيص والأنظمة (ISO, PDPL): 200,000 ريال
  - رأس المال العامل: 300,000 ريال

**إجمالي الاستثمار حتى Year 2:** 1,825,000 ريال (تراكمي)

**العائد المتوقع:**
- **IRR (Internal Rate of Return):** 85% على مدى 5 سنوات
- **Payback Period:** 22 شهر (من بداية Year 2)
- **NPV (Net Present Value) عند معدل خصم 10%:** 23 مليون ريال (Year 5)

---

#### 1.2.3 الجدول الزمني لتحقيق التعادل (Break-Even Timeline)

**نقطة التعادل المتوقعة:**

```
التدفق النقدي التراكمي:

Year 1 Q1: -500,000 ريال   ████████████████░░░░░░░░░░░░
Year 1 Q2: -800,000 ريال   ██████████████░░░░░░░░░░░░░░
Year 1 Q3: -1,100,000 ريال ███████████░░░░░░░░░░░░░░░░░
Year 1 Q4: -625,000 ريال   ████████████████░░░░░░░░░░░░

Year 2 Q1: -400,000 ريال   ██████████████████░░░░░░░░░░
Year 2 Q2: -150,000 ريال   █████████████████████░░░░░░░
Year 2 Q3:  +200,000 ريال  ████████████████████████░░░░ ← نقطة التعادل
Year 2 Q4:  +1,250,000 ريال ████████████████████████████

Year 3 Q4:  +10,350,000 ريال ████████████████████████████
```

**نقطة التعادل:** الربع الثالث من السنة الثانية (Q3 Year 2)

---

#### 1.2.4 مؤشرات الأداء الرئيسية (Key Performance Indicators - KPIs)

##### 1.2.4.1 تكلفة اكتساب العميل (Customer Acquisition Cost - CAC)

**الحساب:**
```
CAC = (إجمالي مصروفات التسويق والمبيعات) / (عدد المكاتب الجدد)
```

**الأهداف:**

| السنة | مصروفات التسويق | المكاتب الجدد | CAC المستهدف |
|------|-----------------|--------------|--------------|
| Year 1 | 200,000 ريال | 150 | 1,333 ريال |
| Year 2 | 600,000 ريال | 350 | 1,714 ريال |
| Year 3 | 1,500,000 ريال | 700 | 2,143 ريال |

**المعيار الصحي:** CAC يجب أن يكون < 50% من الـ LTV السنوي

---

##### 1.2.4.2 القيمة الدائمة للعميل (Lifetime Value - LTV)

**الحساب:**
```
LTV = (متوسط الإيراد السنوي لكل عميل) × (متوسط مدة الاشتراك بالسنوات) × (هامش الربح)
```

**الافتراضات:**
- متوسط الإيراد السنوي: 4,500 ريال
- متوسط مدة الاشتراك: 5 سنوات (معدل الاحتفاظ 80% سنوياً)
- هامش الربح: 70% (بعد استقرار التكاليف)

**LTV المتوقع:** 4,500 × 5 × 0.70 = **15,750 ريال**

**نسبة LTV:CAC المستهدفة:** 7.35:1 (ممتاز - المعيار الصناعي: 3:1)

---

##### 1.2.4.3 الإيرادات الشهرية المتكررة (Monthly Recurring Revenue - MRR)

**تتبع نمو MRR:**

| الشهر | MRR | معدل النمو الشهري |
|-------|-----|-------------------|
| Month 3 | 10,000 ريال | - |
| Month 6 | 25,000 ريال | 150% |
| Month 12 | 45,000 ريال | 80% |
| Month 18 | 175,000 ريال | 289% |
| Month 24 | 325,000 ريال | 86% |
| Month 36 | 1,312,500 ريال | 304% |

**MRR المستهدف (Year 3):** 1,312,500 ريال/شهر = 15,750,000 ريال/سنة

---

##### 1.2.4.4 أهداف معدل الانسحاب (Churn Rate Targets)

**معدل Churn الشهري المستهدف:**

| المرحلة | Churn Rate الشهري | Churn Rate السنوي | الاستراتيجية |
|---------|-------------------|-------------------|--------------|
| Year 1 | 5% | ~46% | طبيعي (عملاء مبكرون، تجريب) |
| Year 2 | 3% | ~31% | تحسين المنتج، نجاح العملاء |
| Year 3 | 1.5% | ~17% | عملاء مستقرون، ميزات متقدمة |

**استراتيجيات الاحتفاظ:**
1. **Onboarding مخصص:** فريق نجاح العملاء (Customer Success)
2. **تدريب مستمر:** ندوات شهرية (Webinars)
3. **دعم استباقي:** مراقبة الاستخدام والتدخل المبكر
4. **برنامج الولاء:** خصومات للاشتراكات طويلة الأجل

---

### 1.3 خارطة الطريق الاستراتيجية والمراحل (Strategic Roadmap & Phasing)

#### نظرة عامة على المراحل:

```
Timeline:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
│ Phase 1 │ Phase 2 │ Phase 3 │ Phase 4 │
│ Foundation │ Advanced │ AI & Market │ Ecosystem │
│ Q1-Q2 │ Q3-Q4 │ Year 2 │ Year 3 │
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

#### 1.3.1 المرحلة الأولى: الأساسيات والأنظمة الجوهرية (Phase 1: Foundation & Core Systems)
**الإطار الزمني:** Q1-Q2 (الأشهر 1-6)

##### 1.3.1.1 البنية التحتية للمصادقة والصلاحيات (Authentication & RBAC Infrastructure)

**الهدف الاستراتيجي:** بناء أساس أمني لا يُخترق، يلبي معايير ISO 27001 ومتطلبات PDPL.

**المخرجات الرئيسية (Deliverables):**

1. **نظام المصادقة المتقدم (Advanced Authentication System):**
   - **JWT + Refresh Token Architecture:** (حل الملاحظة #3)
     - Access Token (صلاحية: 15 دقيقة)
     - Refresh Token (صلاحية: 7 أيام، HttpOnly Cookie)
     - **Silent Refresh Strategy:** تحديث تلقائي قبل انتهاء الـ Token (باستخدام Axios Interceptors)
   
   **المثال التقني (Example):**
   ```typescript
   // Frontend: Axios Interceptor for Silent Token Refresh
   axios.interceptors.response.use(
     (response) => response,
     async (error) => {
       if (error.response?.status === 401 && !error.config._retry) {
         error.config._retry = true;
         const newAccessToken = await refreshAccessToken();
         error.config.headers['Authorization'] = `Bearer ${newAccessToken}`;
         return axios(error.config);
       }
       return Promise.reject(error);
     }
   );
   ```

2. **نظام الصلاحيات المتقدم (Enterprise-Grade RBAC):** (حل الملاحظة #8)
   - **7 أدوار محددة مسبقاً:**
     1. System Administrator (مدير النظام)
     2. Office Owner (مالك المكتب)
     3. Office Manager (مدير المكتب)
     4. Sales Agent (وكيل مبيعات)
     5. Accountant (محاسب)
     6. Viewer (مشاهد فقط)
     7. Custom Roles (أدوار مخصصة)
   
   - **مصفوفة الصلاحيات (Permission Matrix):**
     - **Row-Level Permissions:** التحكم في السجلات (أي عقار يمكن رؤيته/تعديله)
     - **Column-Level Permissions:** التحكم في الحقول (إخفاء السعر، التفاصيل المالية)
     - **Action-Level Permissions:** Create, Read, Update, Delete, Export
   
   **مثال سيناريو (Scenario Example):**
   ```
   موظف "أحمد" - Sales Agent:
   ✓ يمكنه إضافة عقارات جديدة
   ✓ يمكنه رؤية عملائه فقط (وليس عملاء الوكلاء الآخرين)
   ✓ يمكنه رؤية سعر العقار
   ✗ لا يمكنه رؤية عمولة الزملاء
   ✗ لا يمكنه حذف عقارات أضافها مدير المكتب
   ```

**المقاييس الفنية (Technical Metrics):**
- زمن استجابة المصادقة: < 200ms
- معدل فشل Token Refresh: < 0.1%
- تغطية اختبارات RBAC: 100% (Unit Tests)

---

##### 1.3.1.2 معمارية Multi-Tenancy (Multi-Tenancy Architecture)

**الهدف الاستراتيجي:** عزل كامل للبيانات بين المكاتب العقارية مع أداء عالي.

**التصميم التقني:**

1. **Database-Level Isolation:**
   - كل استعلام قاعدة بيانات يتضمن `officeId` في شرط WHERE
   - Row-Level Security (RLS) Policies في Supabase
   
   **مثال SQL:**
   ```sql
   SELECT * FROM properties 
   WHERE office_id = '{{ user.officeId }}' 
   AND deleted_at IS NULL;
   ```

2. **Application-Level Data Segregation:**
   - **Global Middleware:** التحقق من `officeId` في كل طلب API
   - **TypeORM QueryBuilder:** فلترة تلقائية حسب المستأجر
   
   **مثال (NestJS Interceptor):**
   ```typescript
   @Injectable()
   export class TenantInterceptor implements NestInterceptor {
     intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
       const request = context.switchToHttp().getRequest();
       const officeId = request.user.officeId;
       // Inject officeId into all database queries
       return next.handle();
     }
   }
   ```

3. **File Storage Isolation:**
   - S3 Bucket Policies: مجلدات منفصلة لكل مكتب (`/uploads/office-{officeId}/`)
   - Signed URLs: وصول محدود بالوقت

**الفوائد:**
- **أمان:** لا يمكن لمكتب رؤية بيانات مكتب آخر تحت أي ظرف
- **خصوصية:** امتثال كامل لـ PDPL
- **قابلية التوسع:** يمكن نقل مكاتب معينة لخوادم منفصلة لاحقاً

---

##### 1.3.1.3 محرك التحليلات الفورية (Real-Time Analytics Engine)

**الهدف:** (حل الملاحظة #1 - استبدال البيانات الوهمية)

**المكونات الأساسية:**

1. **Backend Aggregation Services:**
   - **PostgreSQL Stored Procedures:** لحسابات معقدة
   - **Redis Caching:** TTL = 5 دقائق للـ Dashboard Metrics
   
   **مثال (Dashboard API):**
   ```typescript
   async getDashboard(officeId: string) {
     const cacheKey = `dashboard:${officeId}`;
     let data = await this.redis.get(cacheKey);
     
     if (!data) {
       data = await this.supabase.rpc('get_dashboard_metrics', {
         p_office_id: officeId
       });
       await this.redis.setex(cacheKey, 300, JSON.stringify(data)); // 5 min TTL
     }
     
     return JSON.parse(data);
   }
   ```

2. **Frontend Data Visualization:**
   - **Recharts Library:** رسوم بيانية تفاعلية
   - **Real-Time Updates:** WebSocket للإشعارات الفورية

**مؤشرات الأداء:**
- **Dashboard Load Time:** < 1.5 ثانية
- **Chart Render Time:** < 500ms
- **Data Freshness:** تحديث كل 5 دقائق

---

##### 1.3.1.4 وحدة إدارة العقارات الأساسية (Core Property Management Module)

**الوظائف الأساسية:**

1. **إضافة عقارات (Property Creation):**
   - نموذج متعدد الخطوات (Multi-Step Form)
   - رفع الصور: (حل الملاحظة #4 - تنفيذ `/api/properties/upload`)
   
   **الحل التقني:**
   ```typescript
   // Backend: File Upload Endpoint
   @Post('upload')
   @UseInterceptors(FileInterceptor('file'))
   async uploadPropertyImage(@UploadedFile() file: Express.Multer.File) {
     const s3Url = await this.s3Service.upload(file, 'property-images');
     return { url: s3Url };
   }
   ```

2. **تصدير واستيراد البيانات:**
   - **Export:** (حل الملاحظة #5 - إصلاح مصادقة endpoint)
   - **Import:** (حل الملاحظة #6 - معالجة القيم الفارغة)
   
   **Column Matching Algorithm:**
   - **Levenshtein Distance:** لمطابقة أسماء الأعمدة تلقائياً
   - **Manual Mapping UI:** للمستخدم للتحكم اليدوي

**المخرجات:**
- 100% من العمليات الأساسية تعمل بدون أخطاء
- دعم استيراد/تصدير ملفات حتى 10,000 صف

---

#### 1.3.2 المرحلة الثانية: الميزات المتقدمة والتكامل (Phase 2: Advanced Features & Integration)
**الإطار الزمني:** Q3-Q4 (الأشهر 7-12)

##### 1.3.2.1 ذكاء الأعمال المتقدم والتحليلات التنبؤية (Advanced BI & Predictive Analytics)

**الهدف:** (حل الملاحظة #2 و #7 - تحليلات متقدمة مع فلاتر ديناميكية)

**المكونات:**

1. **Dynamic Filtering System:**
   - **Frontend Filter Builder:** واجهة سحب وإفلات (Drag & Drop)
   - **Backend Query Builder:** TypeORM QueryBuilder ديناميكي
   
   **مثال (Custom Filter):**
   ```typescript
   // المستخدم يختار: "عقارات | النوع = فيلا | السعر > 500000 | المدينة = الرياض"
   const queryBuilder = this.propertyRepo.createQueryBuilder('property')
     .where('property.type = :type', { type: 'villa' })
     .andWhere('property.price > :price', { price: 500000 })
     .andWhere('property.city = :city', { city: 'Riyadh' })
     .andWhere('property.officeId = :officeId', { officeId });
   ```

2. **Market Intelligence Dashboard:**
   - **بيانات الملاك:** (حسب الملاحظة #7)
     - معدل الشغور (Vacancy Rate)
     - تكاليف الصيانة
     - معدل الاحتفاظ بالمستأجرين
   
   - **بيانات المستأجرين:**
     - Walkability Score
     - Safety Score
     - Connectivity Score
   
   - **بيانات المستثمرين:**
     - Net Rental Yield
     - ROI Predictions
     - Gentrification Index

**المخرجات:**
- 20+ تقرير تحليلي جاهز
- محرك تقارير مخصص (Custom Report Builder)

---

##### 1.3.2.2 تكامل WhatsApp (2FA + إشعارات)

**الهدف:** (حل الملاحظة #16 و #19)

**الوظائف:**

1. **Two-Factor Authentication (2FA):**
   - **تفعيل اختياري:** المستخدم يختار
   - **OTP via WhatsApp:** رمز لمدة 5 دقائق
   - **Backup Codes:** 10 رموز للطوارئ

2. **Notification System:**
   - **أنواع الإشعارات:**
     - تذكير بمواعيد
     - استحقاق دفعات
     - طلبات صيانة جديدة
     - تنبيهات انتهاء العقود

**المتطلبات التقنية:**
- **WhatsApp Business API Account:** (سيُوفر دليل الإعداد)
- **Message Templates:** معتمدة من WhatsApp
- **Webhook Integration:** لاستقبال الردود

**الأداة المساعدة (Setup Guide):**
سيُرفق دليل تفصيلي في `WHATSAPP_SETUP_GUIDE.md` يحتوي على:
1. خطوات التسجيل في WhatsApp Business API
2. إنشاء Message Templates
3. ضبط Webhooks
4. إدارة Rate Limits

---

##### 1.3.2.3 بوابة الخدمة الذاتية للعملاء (Client Self-Service Portal)

**الهدف:** (حل الملاحظة #22)

**المعمارية:**
- **نطاق منفصل:** `client.yourdomain.com` أو `yourdomain.com/client-portal`
- **مصادقة منفصلة:** بيانات اعتماد خاصة بالعملاء (ليست نفس بيانات الموظفين)
- **White-Label:** تخصيص الشعار والألوان لكل مكتب عقاري

**الوظائف الأساسية:**
1. **لوحة العميل (Client Dashboard):**
   - عقاراتي (عقود الإيجار النشطة)
   - دفع الإيجار (تكامل مع بوابات الدفع)
   - طلبات الصيانة
   - الوثائق (العقود، الفواتير)

2. **البحث عن عقارات:**
   - عقارات متاحة للإيجار/البيع
   - فلاتر متقدمة
   - حجز موعد معاينة

**الفوائد:**
- **تقليل عبء العمل:** 40% من الاستفسارات يمكن معالجتها ذاتياً
- **تحسين رضا العملاء:** خدمة 24/7

---

##### 1.3.2.4 الإدارة المالية والفوترة الآلية (Financial Management & Automated Invoicing)

**الوظائف:**

1. **تتبع الإيرادات:**
   - تحصيل الإيجارات
   - عمولات المبيعات
   
2. **إدارة المصروفات:**
   - تكاليف الصيانة
   - رواتب الموظفين
   - المصروفات التشغيلية

3. **توليد الفواتير:**
   - **PDF Export:** مع شعار المكتب
   - **ZATCA Compliant:** فواتير إلكترونية متوافقة
   
4. **التقارير المالية:**
   - قائمة الدخل (P&L)
   - تحليل التدفق النقدي
   - تقارير الضرائب (VAT, Zakat)

**التكامل:**
- **Payment Gateways:** HyperPay, Moyasar, Tap Payments
- **Accounting Software:** تصدير لـ QuickBooks, Xero (اختياري)

---

#### 1.3.3 المرحلة الثالثة: توسع السوق والذكاء الاصطناعي (Phase 3: Market Expansion & AI)
**الإطار الزمني:** Year 2 (الأشهر 13-24)

##### 1.3.3.1 تقييم العقارات بالذكاء الاصطناعي (AI-Powered Property Valuation)

**الهدف:** توفير تقييم فوري ودقيق لقيمة العقار بناءً على:
- الموقع الجغرافي
- مساحة العقار
- عمر العقار
- المرافق المحيطة
- الصفقات الأخيرة في نفس الحي

**التقنيات:**
- **Machine Learning Model:** Random Forest / XGBoost
- **Training Data:** بيانات تاريخية من الهيئة العامة للعقار + بيانات المنصة
- **Accuracy Target:** ±5% من القيمة السوقية الحقيقية

**مثال:**
```
المستخدم يُدخل:
- فيلا، الرياض، حي النرجس
- مساحة 400 م²
- 5 غرف نوم، 4 حمامات
- عمر العقار: 3 سنوات

النظام يتنبأ:
"القيمة المتوقعة: 2,350,000 ريال (±120,000 ريال)"
"مقارنة بالسوق: أعلى من المتوسط بـ 8%"
```

---

##### 1.3.3.2 تحليل المشاعر السوقية (Market Sentiment Analysis)

**الهدف:** رصد ما يُقال عن الأحياء المختلفة على وسائل التواصل الاجتماعي.

**المصادر:**
- Twitter (X)
- منتديات عقارية محلية
- مراجعات Google Maps

**التقنيات:**
- **Natural Language Processing (NLP):** BERT / GPT-based models
- **Sentiment Classification:** Positive, Neutral, Negative
- **Topic Modeling:** استخراج المواضيع الرئيسية (الأمان، النظافة، الخدمات)

**مثال (Output):**
```
حي الياسمين:
- Sentiment Score: 0.75 (إيجابي)
- أكثر الكلمات تكراراً: "هادئ" (120 مرة)، "نظيف" (95 مرة)، "أمان" (80 مرة)
- التحذيرات: "ازدحام مروري" (35 مرة)
```

---

##### 1.3.3.3 توسع دعم اللغات (Multi-Language Support Expansion)

**اللغات المستهدفة:**
- العربية (موجود)
- الإنجليزية (موجود)
- **جديد:** الأوردو (Urdu) - لدعم المقيمين الباكستانيين/الهنود
- **جديد:** البنغالية (Bengali)

**الفوائد:**
- زيادة قاعدة المستخدمين بنسبة 25%
- دعم أفضل للمستأجرين من جنسيات متعددة

---

##### 1.3.3.4 تطبيقات الهاتف المحمول (Mobile Applications)

**المنصات:**
- iOS (Swift/SwiftUI)
- Android (Kotlin/Jetpack Compose)

**الوظائف الأساسية:**
- كل وظائف الويب
- **إضافات خاصة بالموبايل:**
  - التقاط صور العقار مباشرة من الكاميرا
  - إشعارات Push Notifications
  - مسح QR Code للعقارات

**الاستراتيجية:**
- **Phase 1:** نسخة React Native (تسريع التطوير)
- **Phase 2:** Native Apps (أداء أعلى)

---

#### 1.3.4 المرحلة الرابعة: المؤسسات والنظام البيئي (Phase 4: Enterprise & Ecosystem)
**الإطار الزمني:** Year 3 (الأشهر 25-36)

##### 1.3.4.1 سوق API للتكاملات الخارجية (API Marketplace)

**الهدف:** السماح لمطورين خارجيين ببناء تطبيقات تتكامل مع نظامنا.

**المكونات:**
- **Developer Portal:** توثيق شامل للـ API
- **API Keys Management:** مفاتيح API لكل مطور
- **Rate Limiting:** حدود الاستخدام حسب الباقة
- **Revenue Sharing:** نموذج مشاركة الأرباح (70% للمطور، 30% للمنصة)

**أمثلة تكاملات متوقعة:**
- أدوات تسويق عقاري
- خدمات تصوير احترافية
- شركات صيانة
- خدمات تأمين عقاري

---

##### 1.3.4.2 Blockchain للتحقق من العقارات (Property Verification)

**الهدف:** منع الاحتيال وتوثيق الملكية.

**الحل:**
- **NFT للعقارات:** كل عقد مسجل يحصل على NFT فريد على Blockchain
- **Smart Contracts:** تنفيذ تلقائي للعقود عند استيفاء الشروط
- **Immutable Records:** سجلات لا يمكن التلاعب بها

**الشبكة المستهدفة:** Polygon (منخفضة التكلفة، صديقة للبيئة)

---

##### 1.3.4.3 تكامل IoT (Smart Home Data)

**الهدف:** ربط العقارات الذكية بالنظام.

**البيانات المجمعة:**
- استهلاك الكهرباء والماء (مباشر)
- حالة أجهزة التكييف
- حالة أقفال الأبواب الذكية
- كاميرات الأمان

**الفوائد:**
- **للملاك:** مراقبة فورية لاستهلاك الطاقة، كشف الأعطال مبكراً
- **للمستأجرين:** تحكم ذكي عبر التطبيق
- **للصيانة:** تنبيهات تلقائية عند حدوث مشكلة

---

##### 1.3.4.4 التوسع الإقليمي (Regional Expansion - GCC Markets)

**الأسواق المستهدفة:**
1. **الإمارات العربية المتحدة:** (أولوية)
   - TAM: 8,000 مكتب عقاري
   - التحديات: منافسة عالية (Bayut, Property Finder)
   - الاستراتيجية: التركيز على المكاتب الصغيرة والمتوسطة

2. **الكويت:**
   - TAM: 2,500 مكتب
   - الميزة: سوق أقل تشبعاً

3. **قطر، البحرين، عُمان:**
   - TAM مجتمع: 3,000 مكتب

**المتطلبات:**
- **Localization:** امتثال للأنظمة المحلية (مثل RERA في الإمارات)
- **Data Residency:** خوادم محلية في كل دولة (حسب القانون)
- **Partnerships:** شراكات مع جمعيات عقارية محلية

---

### 1.4 إدارة المخاطر واستراتيجية التخفيف (Risk Management & Mitigation Strategy)

#### 1.4.1 المخاطر السوقية (Market Risks)

| المخاطرة | الاحتمالية | التأثير | استراتيجية التخفيف |
|----------|-----------|---------|---------------------|
| **دخول منافس قوي (شركة عالمية)** | متوسط (40%) | عالي | **التمايز:** التركيز على الامتثال المحلي والدعم بالعربية. **البناء السريع:** إطلاق الميزات الأساسية قبل المنافسين. |
| **ركود اقتصادي في قطاع العقارات** | منخفض (20%) | عالي | **التنويع:** توسيع قاعدة العملاء لتشمل القطاع السكني والتجاري. **المرونة:** باقات اشتراك مرنة بأسعار متدرجة. |
| **تغيير في الأنظمة الحكومية** | منخفض (15%) | متوسط | **المراقبة المستمرة:** فريق امتثال لمتابعة التغييرات التنظيمية. **المرونة المعمارية:** قابلية تعديل سريعة. |
| **تشبع السوق المحلي** | منخفض (10%) | متوسط | **التوسع الإقليمي:** دخول أسواق الخليج في Year 3. |

---

#### 1.4.2 المخاطر التقنية (Technical Risks)

| المخاطرة | الاحتمالية | التأثير | استراتيجية التخفيف |
|----------|-----------|---------|---------------------|
| **اختناقات قابلية التوسع (Scalability Bottlenecks)** | متوسط (30%) | عالي | **اختبار الأحمال (Load Testing):** اختبارات شهرية بـ k6. **Horizontal Scaling:** معمارية قابلة للتوسع الأفقي (Docker Swarm/Kubernetes جاهز). |
| **فقدان بيانات أثناء الترحيل (Data Migration)** | منخفض (10%) | حرج | **نسخ احتياطية شاملة:** قبل كل ترحيل. **اختبار شامل في Staging:** محاكاة الإنتاج. **Rollback Plan:** خطة رجوع فورية. |
| **تعطل API خارجية (Third-Party Downtime)** | متوسط (40%) | متوسط | **Circuit Breakers:** قطع الاتصال الآلي عند الفشل. **Fallback Mechanisms:** أنظمة بديلة (مثل SMS بدلاً من WhatsApp). **SLA Monitoring:** مراقبة اتفاقيات مستوى الخدمة. |
| **خرق أمني (Security Breach)** | منخفض (5%) | حرج | **مراجعات أمنية منتظمة:** ربع سنوية. **Penetration Testing:** سنوياً. **Incident Response Plan:** خطة استجابة للحوادث موثقة. |

---

#### 1.4.3 مخاطر الامتثال والتنظيم (Regulatory & Compliance Risks)

| المخاطرة | الاحتمالية | التأثير | استراتيجية التخفيف |
|----------|-----------|---------|---------------------|
| **عدم الامتثال لـ PDPL** | منخفض (10%) | حرج | **مراجعة قانونية:** استشاري قانوني متخصص. **تدقيقات امتثال:** نصف سنوية. **تعيين DPO (Data Protection Officer):** مسؤول حماية البيانات. |
| **فشل شهادة ISO 27001** | منخفض (15%) | متوسط | **Pre-Assessment Audits:** تدقيقات أولية قبل التقديم. **Gap Analysis:** تحليل الفجوات وخطة علاج. |
| **تغيير متطلبات إيجار (Ejar)** | متوسط (25%) | متوسط | **شراكة مع RERA:** قنوات اتصال مباشرة. **API Versioning:** تحديثات سريعة عند تغيير المتطلبات. |

---

#### 1.4.4 المخاطر التشغيلية (Operational Risks)

| المخاطرة | الاحتمالية | التأثير | استراتيجية التخفيف |
|----------|-----------|---------|---------------------|
| **دوران الموظفين الرئيسيين (Key Personnel Turnover)** | متوسط (30%) | عالي | **توثيق شامل:** كل شيء موثق (Code, Architecture, Processes). **Code Reviews:** مراجعات الكود لنشر المعرفة. **Knowledge Transfer:** جلسات نقل معرفة منتظمة. |
| **زحف النطاق (Scope Creep)** | عالي (50%) | متوسط | **Change Control صارم:** لجنة تحكم بالتغيير (Change Control Board). **إطار الأولويات:** MoSCoW Method (Must, Should, Could, Won't). |
| **ضغط الموارد (Resource Constraints)** | متوسط (35%) | متوسط | **توظيف استباقي:** البدء بالتوظيف في Q2. **Outsourcing:** الاستعانة بمصادر خارجية لمهام غير جوهرية (UI/UX Design). |

---

#### 1.4.5 خطة الطوارئ (Contingency Planning)

**السيناريو 1: فشل إطلاق رئيسي (Major Launch Failure)**

**التأثير:** فقدان الثقة، انسحاب عملاء مبكرين.

**خطة الاستجابة:**
1. **Immediate Rollback:** الرجوع للإصدار السابق فوراً (< 15 دقيقة)
2. **Communication:** إشعار فوري للعملاء بالمشكلة والحل
3. **Root Cause Analysis:** تحليل السبب الجذري خلال 24 ساعة
4. **Compensation:** تمديد فترة تجريبية أو خصم للعملاء المتأثرين

---

**السيناريو 2: خرق بيانات (Data Breach)**

**التأثير:** فقدان ثقة، غرامات PDPL، دعاوى قضائية.

**خطة الاستجابة:**
1. **Immediate Containment:** عزل النظام المخترق فوراً
2. **Notification (within 72 hours):** إبلاغ الهيئة الوطنية للأمن السيبراني
3. **Customer Notification:** إعلام العملاء المتأثرين
4. **Forensic Investigation:** تحقيق جنائي رقمي
5. **Remediation:** إصلاح الثغرة + تعزيز الأمان
6. **PR Campaign:** حملة علاقات عامة لاستعادة الثقة

---

**السيناريو 3: فقدان مستثمر رئيسي (Loss of Key Investor)**

**التأثير:** نقص السيولة، تأخير في التطوير.

**خطة الاستجابة:**
1. **Cash Reserve:** الاحتفاظ بـ 6 أشهر نفقات تشغيلية نقداً
2. **Alternative Funding:** بدائل تمويل جاهزة (قروض، مستثمرين آخرين)
3. **Burn Rate Optimization:** تقليل المصروفات غير الأساسية
4. **Revenue Acceleration:** التركيز على تحويل العملاء المحتملين

---

## الملاحظات الختامية للجزء الأول

**ملخص النقاط الرئيسية:**

1. **الفرصة السوقية:** سوق سعودي بقيمة 144 مليون ريال، مع فجوة واضحة في الحلول الرقمية المتكاملة.

2. **التمايز الاستراتيجي:**
   - **ذكاء السوق:** رؤى تنبؤية لا يوفرها المنافسون (حل الملاحظة #7)
   - **امتثال محلي:** ISO 27001 + PDPL + RERA Integration
   - **تجربة عربية أصيلة:** ليس مجرد ترجمة

3. **نموذج مالي قوي:**
   - **Break-Even:** Q3 Year 2
   - **LTV:CAC:** 7.35:1 (ممتاز)
   - **Year 3 Revenue:** 15.75 مليون ريال
   - **Profit Margin:** 66% (Year 3)

4. **خارطة طريق واضحة:**
   - **Phase 1 (Q1-Q2):** الأساسيات (JWT, RBAC, Multi-Tenancy, Analytics)
   - **Phase 2 (Q3-Q4):** الميزات المتقدمة (BI, WhatsApp, Client Portal)
   - **Phase 3 (Year 2):** AI والتوسع (تقييم عقارات، تحليل مشاعر، موبايل)
   - **Phase 4 (Year 3):** النظام البيئي (API Marketplace, Blockchain, IoT, GCC)

5. **إدارة مخاطر شاملة:**
   - تحديد 15+ مخاطرة محتملة
   - خطط تخفيف لكل مخاطرة
   - خطط طوارئ للسيناريوهات الحرجة

---

**الخطوة التالية:**
الانتقال إلى **الجزء الثاني: النظرة التنظيمية والقانونية (PART II: COMPLIANCE & LEGAL VIEW)** الذي سيفصّل كيفية امتثال النظام لـ ISO 27001, ISO 9001, PDPL, RERA, و SAMA.

---

**تاريخ التحديث:** 19 نوفمبر 2025
**الإصدار:** 3.0 - Part I
**الحالة:** مكتمل ✓

---

# **الجزء الثاني: النظرة التنظيمية والقانونية**
## PART II: COMPLIANCE & LEGAL VIEW

---

## 2. الامتثال للمعايير الدولية وأنظمة المملكة

### 2.1 امتثال ISO 27001 (Information Security Management System)

#### 2.1.1 منهجية التطبيق الفني لـ ISO 27001

**المبدأ العام (Theory):**

ISO 27001 ليس مجرد "توثيق سياسات"، بل هو **تطبيق تقني يُدمج في بنية النظام**. كل بند من بنود ISO 27001 يُترجم إلى:
1. **Database Schema Change:** تعديل في قاعدة البيانات
2. **Code Implementation:** تطبيق في الكود (Backend/Frontend)
3. **Infrastructure Configuration:** ضبط في البنية التحتية (Nginx, PM2, PostgreSQL)

---

#### 2.1.2 تطبيق البند A.9 - Access Control (الحماية الفنية لتسجيل الدخول)

##### **A.9.2.1: User Registration and De-registration**

**المتطلب الفني:**

يجب أن يحتوي جدول `user_permissions` على آلية تتبع دقيقة لحالة المستخدم:

```sql
-- Database Schema (PostgreSQL + Supabase)
CREATE TABLE user_permissions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  office_id UUID NOT NULL REFERENCES offices(id) ON DELETE CASCADE,
  user_id UUID,
  name VARCHAR(255) NOT NULL,
  phone VARCHAR(20) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  role VARCHAR(50) DEFAULT 'staff' CHECK (role IN ('system_admin', 'office_admin', 'manager', 'staff', 'accountant', 'technician', 'owner', 'tenant')),
  password_hash TEXT NOT NULL,
  is_active BOOLEAN DEFAULT true,
  permissions JSONB DEFAULT '{}',
  last_login TIMESTAMP,
  failed_login_attempts INT DEFAULT 0, -- ISO 27001 A.9.4.3
  account_locked_until TIMESTAMP, -- ISO 27001 A.9.4.3
  password_expires_at TIMESTAMP, -- ISO 27001 A.9.4.3
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Index for performance
CREATE INDEX idx_user_phone ON user_permissions(phone);
CREATE INDEX idx_user_office ON user_permissions(office_id);
CREATE INDEX idx_user_active ON user_permissions(is_active) WHERE is_active = true;
```

**التطبيق في Backend (NestJS):**

```typescript
// api/src/auth/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { SupabaseService } from '../supabase/supabase.service';

@Injectable()
export class AuthService {
  // ISO 27001 A.9.4.3: Password Complexity
  private readonly PASSWORD_REGEX = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{12,}$/;
  
  // ISO 27001 A.9.4.3: Account Lockout Policy
  private readonly MAX_FAILED_ATTEMPTS = 5;
  private readonly LOCKOUT_DURATION_MINUTES = 30;

  async validateUser(phone: string, password: string): Promise<any> {
    const supabase = this.supabaseService.getClient();
    
    // Step 1: Retrieve user from user_permissions table
    const { data: user, error } = await supabase
      .from('user_permissions')
      .select('*')
      .eq('phone', phone)
      .single();

    if (error || !user) {
      // ISO 27001 A.9.4.2: Avoid revealing whether user exists
      throw new UnauthorizedException('بيانات الدخول غير صحيحة');
    }

    // Step 2: Check if account is locked (ISO 27001 A.9.4.3)
    if (user.account_locked_until && new Date(user.account_locked_until) > new Date()) {
      const minutesLeft = Math.ceil((new Date(user.account_locked_until).getTime() - Date.now()) / 60000);
      throw new UnauthorizedException(`الحساب مقفل. يرجى المحاولة بعد ${minutesLeft} دقيقة`);
    }

    // Step 3: Check if account is active (A.9.2.1)
    if (!user.is_active) {
      throw new UnauthorizedException('حساب المستخدم غير نشط');
    }

    // Step 4: Check if password is expired (A.9.4.3)
    if (user.password_expires_at && new Date(user.password_expires_at) < new Date()) {
      throw new UnauthorizedException('كلمة المرور منتهية. يرجى تغييرها');
    }

    // Step 5: Verify password with bcrypt
    const isPasswordValid = await bcrypt.compare(password, user.password_hash);
    
    if (!isPasswordValid) {
      // Increment failed login attempts
      const newFailedAttempts = (user.failed_login_attempts || 0) + 1;
      
      // Lock account if max attempts reached
      if (newFailedAttempts >= this.MAX_FAILED_ATTEMPTS) {
        const lockUntil = new Date(Date.now() + this.LOCKOUT_DURATION_MINUTES * 60000);
        await supabase
          .from('user_permissions')
          .update({
            failed_login_attempts: newFailedAttempts,
            account_locked_until: lockUntil.toISOString()
          })
          .eq('id', user.id);
        
        throw new UnauthorizedException(`تم قفل الحساب لمدة ${this.LOCKOUT_DURATION_MINUTES} دقيقة بسبب تجاوز عدد المحاولات`);
      }

      // Update failed attempts
      await supabase
        .from('user_permissions')
        .update({ failed_login_attempts: newFailedAttempts })
        .eq('id', user.id);

      throw new UnauthorizedException('بيانات الدخول غير صحيحة');
    }

    // Step 6: Reset failed attempts on successful login
    await supabase
      .from('user_permissions')
      .update({
        failed_login_attempts: 0,
        account_locked_until: null,
        last_login: new Date().toISOString()
      })
      .eq('id', user.id);

    // Return user without sensitive data
    const { password_hash, ...result } = user;
    return result;
  }

  // ISO 27001 A.9.4.3: Password Validation on Registration
  validatePasswordComplexity(password: string): boolean {
    return this.PASSWORD_REGEX.test(password);
  }
}
```

**حل الملاحظة #3 (Token Expiration):**

```typescript
// api/src/auth/auth.service.ts
async login(user: any): Promise<{ accessToken: string; refreshToken: string }> {
  const payload = {
    sub: user.id,
    user_id: user.user_id || user.id,
    office_id: user.office_id,
    role: user.role,
    permissions: user.permissions
  };

  // Access Token: 15 minutes (ISO 27001 A.9.4.1)
  const accessToken = this.jwtService.sign(payload, {
    secret: process.env.JWT_SECRET,
    expiresIn: '15m'
  });

  // Refresh Token: 7 days (stored securely)
  const refreshToken = this.jwtService.sign(
    { sub: user.id, type: 'refresh' },
    {
      secret: process.env.JWT_REFRESH_SECRET,
      expiresIn: '7d'
    }
  );

  // Store refresh token in database with rotation
  await this.storeRefreshToken(user.id, refreshToken);

  return { accessToken, refreshToken };
}

// Refresh Token Storage (ISO 27001 A.10.1.1)
private async storeRefreshToken(userId: string, token: string): Promise<void> {
  const supabase = this.supabaseService.getClient();
  
  const hashedToken = await bcrypt.hash(token, 10);
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

  await supabase.from('refresh_tokens').insert({
    user_id: userId,
    token_hash: hashedToken,
    expires_at: expiresAt.toISOString(),
    is_revoked: false
  });
}

// Silent Token Refresh (حل الملاحظة #3)
async refreshAccessToken(userId: string, refreshToken: string): Promise<string> {
  const supabase = this.supabaseService.getClient();

  // Verify refresh token exists and is not revoked
  const { data: tokens } = await supabase
    .from('refresh_tokens')
    .select('*')
    .eq('user_id', userId)
    .eq('is_revoked', false)
    .gt('expires_at', new Date().toISOString());

  if (!tokens || tokens.length === 0) {
    throw new UnauthorizedException('Refresh token expired or revoked');
  }

  // Verify token hash
  let validToken = null;
  for (const t of tokens) {
    if (await bcrypt.compare(refreshToken, t.token_hash)) {
      validToken = t;
      break;
    }
  }

  if (!validToken) {
    throw new UnauthorizedException('Invalid refresh token');
  }

  // Get fresh user data
  const { data: user } = await supabase
    .from('user_permissions')
    .select('*')
    .eq('id', userId)
    .single();

  if (!user || !user.is_active) {
    throw new UnauthorizedException('User account is inactive');
  }

  // Generate new access token
  const payload = {
    sub: user.id,
    user_id: user.user_id || user.id,
    office_id: user.office_id,
    role: user.role,
    permissions: user.permissions
  };

  return this.jwtService.sign(payload, {
    secret: process.env.JWT_SECRET,
    expiresIn: '15m'
  });
}
```

**Frontend Implementation (Axios Interceptor):**

```typescript
// Web/src/lib/axios.ts
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001',
  withCredentials: true // For HttpOnly cookies
});

// Request Interceptor: Attach Access Token
api.interceptors.request.use(
  (config) => {
    const accessToken = localStorage.getItem('accessToken');
    if (accessToken) {
      config.headers['Authorization'] = `Bearer ${accessToken}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response Interceptor: Silent Token Refresh (حل الملاحظة #3)
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // If error is 401 and we haven't retried yet
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        // Attempt silent refresh using HttpOnly cookie
        const { data } = await axios.post(
          `${process.env.NEXT_PUBLIC_API_URL}/api/auth/refresh`,
          {},
          { withCredentials: true }
        );

        // Store new access token
        localStorage.setItem('accessToken', data.accessToken);

        // Retry original request with new token
        originalRequest.headers['Authorization'] = `Bearer ${data.accessToken}`;
        return api(originalRequest);
      } catch (refreshError) {
        // Refresh failed, redirect to login
        localStorage.removeItem('accessToken');
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

export default api;
```

---

##### **A.9.4.5: Review of User Access Rights**

**المتطلب الفني:**

يجب إجراء مراجعة دورية لصلاحيات المستخدمين (كل 90 يوماً):

```typescript
// api/src/auth/auth.service.ts
async generateAccessReviewReport(officeId: string): Promise<any> {
  const supabase = this.supabaseService.getClient();

  const { data: users } = await supabase
    .from('user_permissions')
    .select('*')
    .eq('office_id', officeId)
    .eq('is_active', true);

  const reviewData = users.map(user => ({
    userId: user.id,
    name: user.name,
    role: user.role,
    lastLogin: user.last_login,
    passwordAge: this.calculatePasswordAge(user.updated_at),
    permissions: user.permissions,
    requiresReview: this.calculatePasswordAge(user.updated_at) > 90
  }));

  return reviewData;
}

private calculatePasswordAge(updatedAt: string): number {
  const daysSinceUpdate = Math.floor(
    (Date.now() - new Date(updatedAt).getTime()) / (1000 * 60 * 60 * 24)
  );
  return daysSinceUpdate;
}
```

---

#### 2.1.3 تطبيق البند A.10 - Cryptography (التشفير الفني)

##### **A.10.1.1: Encryption at Rest**

**المتطلب الفني:**

يجب تشفير الحقول الحساسة في قاعدة البيانات باستخدام `pgcrypto`:

```sql
-- Enable pgcrypto extension
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Encryption/Decryption Functions
CREATE OR REPLACE FUNCTION encrypt_sensitive_data(data TEXT, key TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN encode(pgp_sym_encrypt(data, key), 'base64');
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION decrypt_sensitive_data(encrypted_data TEXT, key TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN pgp_sym_decrypt(decode(encrypted_data, 'base64'), key);
END;
$$ LANGUAGE plpgsql;
```

**تطبيق التشفير على جدول Customers:**

```sql
-- Modify customers table to encrypt sensitive fields
ALTER TABLE customers ADD COLUMN national_id_encrypted TEXT;
ALTER TABLE customers ADD COLUMN phone_encrypted TEXT;

-- Trigger to auto-encrypt on INSERT/UPDATE
CREATE OR REPLACE FUNCTION encrypt_customer_data()
RETURNS TRIGGER AS $$
BEGIN
  -- Encrypt national_id if provided
  IF NEW.national_id IS NOT NULL THEN
    NEW.national_id_encrypted = encrypt_sensitive_data(
      NEW.national_id, 
      current_setting('app.encryption_key')
    );
    NEW.national_id = NULL; -- Clear plaintext
  END IF;

  -- Encrypt phone
  IF NEW.phone IS NOT NULL THEN
    NEW.phone_encrypted = encrypt_sensitive_data(
      NEW.phone, 
      current_setting('app.encryption_key')
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_encrypt_customer
BEFORE INSERT OR UPDATE ON customers
FOR EACH ROW
EXECUTE FUNCTION encrypt_customer_data();
```

**Backend Implementation:**

```typescript
// api/src/customers/customers.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { SupabaseService } from '../supabase/supabase.service';

@Injectable()
export class CustomersService {
  constructor(
    private readonly supabaseService: SupabaseService,
    private readonly configService: ConfigService
  ) {}

  async findCustomer(officeId: string, customerId: string): Promise<any> {
    const supabase = this.supabaseService.getClient();
    const encryptionKey = this.configService.get<string>('ENCRYPTION_KEY');

    // Query with decryption
    const { data, error } = await supabase.rpc('get_customer_decrypted', {
      p_office_id: officeId,
      p_customer_id: customerId,
      p_key: encryptionKey
    });

    if (error) throw error;
    return data;
  }
}
```

```sql
-- Stored Procedure for Decryption
CREATE OR REPLACE FUNCTION get_customer_decrypted(
  p_office_id UUID,
  p_customer_id UUID,
  p_key TEXT
)
RETURNS TABLE (
  id UUID,
  name TEXT,
  phone TEXT,
  email TEXT,
  national_id TEXT,
  city TEXT,
  address TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id,
    c.name,
    decrypt_sensitive_data(c.phone_encrypted, p_key) AS phone,
    c.email,
    decrypt_sensitive_data(c.national_id_encrypted, p_key) AS national_id,
    c.city,
    c.address
  FROM customers c
  WHERE c.office_id = p_office_id
    AND c.id = p_customer_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

##### **A.10.1.2: Encryption in Transit (TLS/SSL)**

**المتطلب الفني:**

جميع الاتصالات يجب أن تكون عبر HTTPS/TLS 1.3:

```nginx
# /etc/nginx/sites-available/realestate-system
server {
    listen 80;
    server_name yourdomain.com;
    
    # Redirect all HTTP to HTTPS (ISO 27001 A.10.1.2)
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name yourdomain.com;

    # SSL Configuration (ISO 27001 A.10.1.2)
    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;
    
    # Force TLS 1.3 only
    ssl_protocols TLSv1.3;
    ssl_ciphers 'TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384';
    ssl_prefer_server_ciphers off;

    # HSTS (ISO 27001 A.10.1.2)
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
    
    # Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';" always;

    location /api {
        proxy_pass http://localhost:3001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
```

---

#### 2.1.4 تطبيق البند A.12 - Operations Security

##### **A.12.4.1: Event Logging**

**المتطلب الفني:**

يجب تسجيل جميع الأحداث الأمنية الحرجة:

```sql
-- Audit Log Table (ISO 27001 A.12.4.1)
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES user_permissions(id),
  office_id UUID REFERENCES offices(id),
  action VARCHAR(100) NOT NULL, -- 'LOGIN', 'LOGOUT', 'CREATE', 'UPDATE', 'DELETE', 'EXPORT'
  entity_type VARCHAR(50), -- 'Property', 'Customer', 'Contract'
  entity_id UUID,
  ip_address INET,
  user_agent TEXT,
  request_payload JSONB,
  response_status INT,
  timestamp TIMESTAMP DEFAULT NOW()
);

-- Index for fast queries
CREATE INDEX idx_audit_user ON audit_logs(user_id);
CREATE INDEX idx_audit_office ON audit_logs(office_id);
CREATE INDEX idx_audit_timestamp ON audit_logs(timestamp DESC);
CREATE INDEX idx_audit_action ON audit_logs(action);
```

**NestJS Interceptor للتسجيل التلقائي:**

```typescript
// api/src/common/interceptors/audit-log.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { SupabaseService } from '../../supabase/supabase.service';

@Injectable()
export class AuditLogInterceptor implements NestInterceptor {
  constructor(private readonly supabaseService: SupabaseService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const response = context.switchToHttp().getResponse();
    
    const user = request.user;
    const method = request.method;
    const url = request.url;

    // Map HTTP method to action
    const actionMap = {
      'POST': 'CREATE',
      'PUT': 'UPDATE',
      'PATCH': 'UPDATE',
      'DELETE': 'DELETE',
      'GET': 'READ'
    };

    return next.handle().pipe(
      tap(async (data) => {
        const supabase = this.supabaseService.getClient();

        await supabase.from('audit_logs').insert({
          user_id: user?.id,
          office_id: user?.office_id,
          action: actionMap[method] || method,
          entity_type: this.extractEntityType(url),
          entity_id: data?.id || null,
          ip_address: request.ip,
          user_agent: request.headers['user-agent'],
          request_payload: method !== 'GET' ? request.body : null,
          response_status: response.statusCode
        });
      })
    );
  }

  private extractEntityType(url: string): string {
    if (url.includes('/properties')) return 'Property';
    if (url.includes('/customers')) return 'Customer';
    if (url.includes('/contracts')) return 'Contract';
    if (url.includes('/appointments')) return 'Appointment';
    return 'Unknown';
  }
}
```

**تطبيق الـ Interceptor على Controllers:**

```typescript
// api/src/properties/properties.controller.ts
import { Controller, UseInterceptors } from '@nestjs/common';
import { AuditLogInterceptor } from '../common/interceptors/audit-log.interceptor';

@Controller('properties')
@UseInterceptors(AuditLogInterceptor) // ISO 27001 A.12.4.1
export class PropertiesController {
  // ... controller methods
}
```

---

### 2.2 امتثال نظام حماية البيانات الشخصية السعودي (PDPL)

#### 2.2.1 المادة 5: الحصول على الموافقة (Consent Management)

**المتطلب الفني:**

يجب الحصول على موافقة صريحة قبل جمع أي بيانات شخصية:

```sql
-- Consent Management Table
CREATE TABLE customer_consents (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  customer_id UUID REFERENCES customers(id) ON DELETE CASCADE,
  office_id UUID NOT NULL,
  consent_type VARCHAR(50) NOT NULL, -- 'DATA_COLLECTION', 'MARKETING', 'THIRD_PARTY_SHARING'
  consent_given BOOLEAN NOT NULL DEFAULT false,
  consent_text TEXT NOT NULL, -- Exact text shown to customer
  consented_at TIMESTAMP,
  ip_address INET,
  user_agent TEXT,
  revoked_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_consent_customer ON customer_consents(customer_id);
```

**Backend Implementation:**

```typescript
// api/src/customers/dto/create-customer.dto.ts
import { IsBoolean, IsNotEmpty, IsString } from 'class-validator';

export class CreateCustomerDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  phone: string;

  // PDPL Compliance: Consent must be explicit
  @IsBoolean()
  @IsNotEmpty()
  dataCollectionConsent: boolean;

  @IsBoolean()
  marketingConsent: boolean;

  @IsBoolean()
  thirdPartyConsent: boolean;
}
```

```typescript
// api/src/customers/customers.service.ts
async createCustomer(officeId: string, dto: CreateCustomerDto, req: any): Promise<any> {
  const supabase = this.supabaseService.getClient();

  // PDPL Check: Consent must be true for data collection
  if (!dto.dataCollectionConsent) {
    throw new BadRequestException('يجب الموافقة على سياسة جمع البيانات الشخصية');
  }

  // Create customer
  const { data: customer, error } = await supabase
    .from('customers')
    .insert({
      office_id: officeId,
      name: dto.name,
      phone: dto.phone,
      email: dto.email,
      national_id: dto.nationalId
    })
    .select()
    .single();

  if (error) throw error;

  // Store consents (PDPL Article 5)
  await supabase.from('customer_consents').insert([
    {
      customer_id: customer.id,
      office_id: officeId,
      consent_type: 'DATA_COLLECTION',
      consent_given: dto.dataCollectionConsent,
      consent_text: 'أوافق على جمع واستخدام بياناتي الشخصية لأغراض إدارة العقارات',
      consented_at: new Date().toISOString(),
      ip_address: req.ip,
      user_agent: req.headers['user-agent']
    },
    {
      customer_id: customer.id,
      office_id: officeId,
      consent_type: 'MARKETING',
      consent_given: dto.marketingConsent || false,
      consent_text: 'أوافق على تلقي عروض تسويقية عبر الهاتف أو البريد الإلكتروني',
      consented_at: dto.marketingConsent ? new Date().toISOString() : null,
      ip_address: req.ip,
      user_agent: req.headers['user-agent']
    }
  ]);

  return customer;
}
```

---

#### 2.2.2 المادة 8: حق الوصول والحذف (Right to Access and Erasure)

**المتطلب الفني:**

يجب توفير API للعميل للحصول على نسخة من بياناته أو حذفها:

```typescript
// api/src/customers/customers.controller.ts
@Controller('customers')
export class CustomersController {
  
  // PDPL Article 8: Right to Access
  @Get(':id/data-export')
  @Roles('system_admin', 'office_admin', 'manager')
  async exportCustomerData(
    @Req() req: any,
    @Param('id') customerId: string
  ): Promise<any> {
    const officeId = req.user.office_id;

    const supabase = this.supabaseService.getClient();

    // Get all customer data
    const { data: customer } = await supabase
      .from('customers')
      .select('*')
      .eq('id', customerId)
      .eq('office_id', officeId)
      .single();

    // Get customer interactions
    const { data: interactions } = await supabase
      .from('customer_interactions')
      .select('*')
      .eq('customer_id', customerId)
      .eq('office_id', officeId);

    // Get consents
    const { data: consents } = await supabase
      .from('customer_consents')
      .select('*')
      .eq('customer_id', customerId);

    // PDPL Compliance: Return all data in readable format
    return {
      customer,
      interactions,
      consents,
      exportedAt: new Date().toISOString(),
      note: 'هذه نسخة كاملة من بياناتك الشخصية المخزنة لدينا وفقاً لنظام حماية البيانات الشخصية السعودي'
    };
  }

  // PDPL Article 8: Right to Erasure
  @Delete(':id/gdpr-delete')
  @Roles('system_admin', 'office_admin')
  async permanentlyDeleteCustomer(
    @Req() req: any,
    @Param('id') customerId: string
  ): Promise<any> {
    const officeId = req.user.office_id;
    const supabase = this.supabaseService.getClient();

    // PDPL: Log the deletion request
    await supabase.from('audit_logs').insert({
      user_id: req.user.id,
      office_id: officeId,
      action: 'GDPR_DELETE',
      entity_type: 'Customer',
      entity_id: customerId,
      request_payload: { reason: 'Customer requested permanent deletion (PDPL Article 8)' }
    });

    // Delete customer and all related data (cascade)
    const { error } = await supabase
      .from('customers')
      .delete()
      .eq('id', customerId)
      .eq('office_id', officeId);

    if (error) throw error;

    return {
      success: true,
      message: 'تم حذف بيانات العميل بشكل دائم وفقاً لنظام حماية البيانات الشخصية'
    };
  }
}
```

---

#### 2.2.3 المادة 17: سيادة البيانات (Data Sovereignty)

**المتطلب الفني:**

يجب تخزين جميع البيانات داخل المملكة العربية السعودية:

**Supabase Configuration:**

```typescript
// api/src/supabase/supabase.service.ts
import { Injectable } from '@nestjs/common';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class SupabaseService {
  private supabase: SupabaseClient;

  constructor(private readonly configService: ConfigService) {
    const supabaseUrl = this.configService.get<string>('SUPABASE_URL');
    const supabaseKey = this.configService.get<string>('SUPABASE_SERVICE_ROLE_KEY');

    // PDPL Article 17: Ensure Supabase region is set to Middle East
    // Supabase Project must be created in AWS ME-SOUTH-1 (Bahrain) region
    if (!supabaseUrl.includes('supabase.co')) {
      throw new Error('PDPL Violation: Supabase URL must be from approved region');
    }

    this.supabase = createClient(supabaseUrl, supabaseKey, {
      auth: {
        persistSession: false
      },
      db: {
        schema: 'public'
      }
    });
  }

  getClient(): SupabaseClient {
    return this.supabase;
  }
}
```

**البنية التحتية (Infrastructure as Code):**

```yaml
# docker-compose.yml للبيئة المحلية
version: '3.8'
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: real_estate_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # PDPL: Ensure data volume is in compliant region
    ports:
      - "5432:5432"
    networks:
      - app_network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    networks:
      - app_network

volumes:
  postgres_data:
    driver: local
    # In production, use AWS EBS volumes in me-south-1

networks:
  app_network:
    driver: bridge
```

---

### 2.3 التكامل مع منصة إيجار (Ejar Platform Integration)

#### 2.3.1 متطلبات التكامل الفني مع Ejar API

**البنية المعمارية:**

```typescript
// api/src/ejar/ejar.service.ts
import { Injectable, HttpException } from '@nestjs/common';
import axios, { AxiosInstance } from 'axios';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class EjarService {
  private ejarClient: AxiosInstance;

  constructor(private readonly configService: ConfigService) {
    this.ejarClient = axios.create({
      baseURL: this.configService.get<string>('EJAR_API_URL', 'https://api.ejar.sa/v1'),
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    });

    // Axios Interceptor for Authentication
    this.ejarClient.interceptors.request.use(
      async (config) => {
        const token = await this.getEjarAccessToken();
        config.headers['Authorization'] = `Bearer ${token}`;
        return config;
      },
      (error) => Promise.reject(error)
    );
  }

  // OAuth2 Token Management
  private async getEjarAccessToken(): Promise<string> {
    const clientId = this.configService.get<string>('EJAR_CLIENT_ID');
    const clientSecret = this.configService.get<string>('EJAR_CLIENT_SECRET');

    const { data } = await axios.post('https://auth.ejar.sa/oauth/token', {
      grant_type: 'client_credentials',
      client_id: clientId,
      client_secret: clientSecret,
      scope: 'contracts:create contracts:read contracts:update'
    });

    return data.access_token;
  }

  // Register Contract with Ejar
  async registerContract(contractData: any): Promise<any> {
    try {
      const payload = {
        contractNumber: contractData.contract_number,
        propertyId: contractData.property_id,
        landlordId: contractData.landlord_national_id,
        tenantId: contractData.tenant_national_id,
        startDate: contractData.start_date,
        endDate: contractData.end_date,
        monthlyRent: contractData.monthly_rent,
        paymentMethod: contractData.payment_method,
        propertyDetails: {
          type: contractData.property_type,
          address: contractData.property_address,
          city: contractData.property_city,
          district: contractData.property_district
        }
      };

      const { data } = await this.ejarClient.post('/contracts', payload);

      return {
        success: true,
        ejarContractId: data.id,
        ejarStatus: data.status,
        registrationDate: data.created_at
      };
    } catch (error) {
      throw new HttpException(
        `فشل التسجيل في منصة إيجار: ${error.response?.data?.message || error.message}`,
        error.response?.status || 500
      );
    }
  }

  // Verify Contract Status
  async verifyContractStatus(ejarContractId: string): Promise<any> {
    const { data } = await this.ejarClient.get(`/contracts/${ejarContractId}`);
    
    return {
      status: data.status, // 'pending', 'active', 'expired', 'terminated'
      verifiedAt: new Date().toISOString(),
      landlordSignature: data.landlord_signature_status,
      tenantSignature: data.tenant_signature_status
    };
  }
}
```

**Database Schema للتكامل مع Ejar:**

```sql
-- Ejar Integration Tracking
ALTER TABLE rental_contracts ADD COLUMN ejar_contract_id VARCHAR(255);
ALTER TABLE rental_contracts ADD COLUMN ejar_status VARCHAR(50);
ALTER TABLE rental_contracts ADD COLUMN ejar_registered_at TIMESTAMP;
ALTER TABLE rental_contracts ADD COLUMN ejar_last_sync TIMESTAMP;

CREATE INDEX idx_contract_ejar ON rental_contracts(ejar_contract_id);
```

---

### 2.4 الامتثال لمتطلبات هيئة الزكاة والضريبة والجمارك (ZATCA)

#### 2.4.1 إصدار الفواتير الإلكترونية (E-Invoicing Phase 2)

**المتطلب الفني:**

يجب إصدار فواتير إلكترونية متوافقة مع معايير ZATCA:

```typescript
// api/src/invoices/invoices.service.ts
import { Injectable } from '@nestjs/common';
import { create } from 'xmlbuilder2';
import * as QRCode from 'qrcode';
import * as crypto from 'crypto';

@Injectable()
export class InvoicesService {
  // Generate ZATCA-compliant XML Invoice
  async generateZATCAInvoice(contractId: string, paymentId: string): Promise<string> {
    const supabase = this.supabaseService.getClient();

    // Fetch invoice data
    const { data: payment } = await supabase
      .from('rental_payments')
      .select(`
        *,
        rental_contracts (
          *,
          properties (*),
          customers (*)
        )
      `)
      .eq('id', paymentId)
      .single();

    const contract = payment.rental_contracts;
    const property = contract.properties;
    const customer = contract.customers;

    // Generate Invoice Hash (ZATCA Requirement)
    const invoiceHash = this.generateInvoiceHash(payment);

    // Build XML (UBL 2.1 Format)
    const xml = create({ version: '1.0', encoding: 'UTF-8' })
      .ele('Invoice', { 
        'xmlns': 'urn:oasis:names:specification:ubl:schema:xsd:Invoice-2',
        'xmlns:cac': 'urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2',
        'xmlns:cbc': 'urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2'
      })
        .ele('cbc:ID').txt(payment.id).up()
        .ele('cbc:IssueDate').txt(new Date().toISOString().split('T')[0]).up()
        .ele('cbc:IssueTime').txt(new Date().toTimeString().split(' ')[0]).up()
        .ele('cbc:InvoiceTypeCode', { name: 'Tax Invoice' }).txt('388').up()
        .ele('cbc:DocumentCurrencyCode').txt('SAR').up()
        .ele('cbc:TaxCurrencyCode').txt('SAR').up()
        
        // Supplier (Office)
        .ele('cac:AccountingSupplierParty')
          .ele('cac:Party')
            .ele('cac:PartyIdentification')
              .ele('cbc:ID', { schemeID: 'CRN' }).txt(contract.office_cr_number).up()
            .up()
            .ele('cac:PartyLegalEntity')
              .ele('cbc:RegistrationName').txt(contract.office_name).up()
            .up()
          .up()
        .up()

        // Customer (Tenant)
        .ele('cac:AccountingCustomerParty')
          .ele('cac:Party')
            .ele('cac:PartyIdentification')
              .ele('cbc:ID', { schemeID: 'NAT' }).txt(customer.national_id).up()
            .up()
            .ele('cac:PartyLegalEntity')
              .ele('cbc:RegistrationName').txt(customer.name).up()
            .up()
          .up()
        .up()

        // Tax Total (VAT 15%)
        .ele('cac:TaxTotal')
          .ele('cbc:TaxAmount', { currencyID: 'SAR' }).txt((payment.amount * 0.15).toFixed(2)).up()
        .up()

        // Legal Monetary Total
        .ele('cac:LegalMonetaryTotal')
          .ele('cbc:TaxExclusiveAmount', { currencyID: 'SAR' }).txt((payment.amount / 1.15).toFixed(2)).up()
          .ele('cbc:TaxInclusiveAmount', { currencyID: 'SAR' }).txt(payment.amount.toFixed(2)).up()
          .ele('cbc:PayableAmount', { currencyID: 'SAR' }).txt(payment.amount.toFixed(2)).up()
        .up()

        // Invoice Line
        .ele('cac:InvoiceLine')
          .ele('cbc:ID').txt('1').up()
          .ele('cbc:InvoicedQuantity', { unitCode: 'MON' }).txt('1').up()
          .ele('cbc:LineExtensionAmount', { currencyID: 'SAR' }).txt((payment.amount / 1.15).toFixed(2)).up()
          .ele('cac:Item')
            .ele('cbc:Description').txt(`إيجار ${property.title} - شهر ${payment.month}`).up()
          .up()
        .up()

        // QR Code Data (ZATCA Requirement)
        .ele('cac:AdditionalDocumentReference')
          .ele('cbc:ID').txt('QR').up()
          .ele('cac:Attachment')
            .ele('cbc:EmbeddedDocumentBinaryObject', { mimeCode: 'text/plain' })
              .txt(await this.generateZATCAQRCode(payment, invoiceHash))
            .up()
          .up()
        .up()

        // Cryptographic Stamp
        .ele('cac:Signature')
          .ele('cbc:ID').txt('urn:oasis:names:specification:ubl:signature:Invoice').up()
          .ele('cbc:SignatureMethod').txt('urn:oasis:names:specification:ubl:dsig:enveloped:xades').up()
        .up()

      .up()
    .end({ prettyPrint: true });

    return xml;
  }

  // Generate Invoice Hash (SHA-256)
  private generateInvoiceHash(payment: any): string {
    const dataToHash = `${payment.id}|${payment.amount}|${payment.due_date}|${payment.rental_contracts.office_vat_number}`;
    return crypto.createHash('sha256').update(dataToHash).digest('hex');
  }

  // Generate ZATCA QR Code (TLV Format)
  private async generateZATCAQRCode(payment: any, invoiceHash: string): Promise<string> {
    const contract = payment.rental_contracts;
    
    // TLV Encoding (Tag-Length-Value)
    const tlvData = Buffer.concat([
      this.tlvEncode(1, contract.office_name),           // Seller Name
      this.tlvEncode(2, contract.office_vat_number),     // Seller VAT Number
      this.tlvEncode(3, new Date().toISOString()),       // Invoice Date
      this.tlvEncode(4, payment.amount.toFixed(2)),      // Total with VAT
      this.tlvEncode(5, (payment.amount * 0.15).toFixed(2)), // VAT Amount
      this.tlvEncode(6, invoiceHash)                     // Invoice Hash
    ]);

    const qrDataBase64 = tlvData.toString('base64');
    
    // Generate QR Code Image
    const qrCodeImage = await QRCode.toDataURL(qrDataBase64);
    
    return qrDataBase64;
  }

  // TLV Encoding Helper
  private tlvEncode(tag: number, value: string): Buffer {
    const valueBuffer = Buffer.from(value, 'utf8');
    const tagBuffer = Buffer.from([tag]);
    const lengthBuffer = Buffer.from([valueBuffer.length]);
    return Buffer.concat([tagBuffer, lengthBuffer, valueBuffer]);
  }

  // Report Invoice to ZATCA (Phase 2 Requirement)
  async reportInvoiceToZATCA(invoiceXml: string, invoiceHash: string): Promise<any> {
    const zatcaClient = axios.create({
      baseURL: process.env.ZATCA_API_URL || 'https://api.zatca.gov.sa/compliance',
      headers: {
        'Content-Type': 'application/xml',
        'Authorization': `Bearer ${process.env.ZATCA_API_KEY}`,
        'Accept-Version': 'V2'
      }
    });

    try {
      const { data } = await zatcaClient.post('/invoices/reporting', {
        invoiceXml,
        invoiceHash
      });

      return {
        success: true,
        zatcaInvoiceId: data.invoice_id,
        zatcaStatus: data.status,
        reportedAt: new Date().toISOString()
      };
    } catch (error) {
      throw new HttpException(
        `فشل إرسال الفاتورة لهيئة الزكاة: ${error.response?.data?.message}`,
        error.response?.status || 500
      );
    }
  }
}
```

---

## الملاحظات الختامية للجزء الثاني

**ملخص النقاط الرئيسية:**

1. **ISO 27001 Implementation:**
   - كل بند ISO مُطبّق على مستوى الكود (ليس توثيق فقط)
   - Password Complexity: Regex محدد
   - Account Lockout: 5 محاولات، قفل لمدة 30 دقيقة
   - Encryption at Rest: pgcrypto لحقول `national_id`, `phone`
   - TLS 1.3: إجباري على كل Connections

2. **PDPL Compliance:**
   - Consent Management: جدول `customer_consents` مع IP/User-Agent tracking
   - Right to Access: API endpoint لتصدير كل بيانات العميل
   - Right to Erasure: API endpoint للحذف الدائم (GDPR Delete)
   - Data Sovereignty: Supabase في منطقة الشرق الأوسط

3. **Ejar Integration:**
   - OAuth2 Authentication مع Ejar API
   - Register Contract: API endpoint لتسجيل عقود الإيجار
   - Status Sync: جدول tracking لحالة العقد في إيجار

4. **ZATCA E-Invoicing:**
   - UBL 2.1 XML Format (معيار عالمي)
   - QR Code: TLV Encoding وفقاً لمتطلبات ZATCA Phase 2
   - Invoice Hash: SHA-256
   - Reporting API: إرسال الفواتير لهيئة الزكاة

---

**الخطوة التالية:**
الانتقال إلى **الجزء الثالث: النظرة التشغيلية (PART III: OPERATIONAL VIEW)** الذي سيفصّل Multi-Tenancy Architecture و RBAC Matrix الكامل.

---

**تاريخ التحديث:** 19 نوفمبر 2025
**الإصدار:** 3.0 - Part II
**الحالة:** مكتمل ✓

---

# **الجزء الثالث: النظرة التشغيلية**
## PART III: OPERATIONAL VIEW

---

## 3. البنية التشغيلية للنظام

### 3.1 معمارية Multi-Tenancy (العزل الكامل بين المكاتب العقارية)

#### 3.1.1 مستويات العزل (Isolation Levels)

**المبدأ الأساسي:**

Multi-Tenancy ليس "مجرد إضافة `office_id` في SQL". بل هو **نظام عزل متعدد المستويات**:

1. **Database-Level Isolation:** على مستوى قاعدة البيانات
2. **Application-Level Scoping:** على مستوى التطبيق (Backend)
3. **Frontend State Isolation:** على مستوى الواجهة (Frontend)
4. **File Storage Isolation:** على مستوى التخزين (S3/Object Storage)

---

##### **Level 1: Database-Level Isolation**

**القاعدة الحديدية:**

كل جدول (Table) في قاعدة البيانات **يجب** أن يحتوي على عمود `office_id`:

```sql
-- Example: Properties Table
CREATE TABLE properties (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  office_id UUID NOT NULL REFERENCES offices(id) ON DELETE CASCADE, -- CRITICAL
  title VARCHAR(255) NOT NULL,
  property_type VARCHAR(50),
  listing_type VARCHAR(50),
  price DECIMAL(12, 2),
  city VARCHAR(100),
  district VARCHAR(100),
  deleted_at TIMESTAMP, -- Soft delete
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Index for Multi-Tenancy Performance
CREATE INDEX idx_properties_office ON properties(office_id);
CREATE INDEX idx_properties_office_active ON properties(office_id) WHERE deleted_at IS NULL;
```

**Row-Level Security (RLS) Policy:**

```sql
-- Enable Row-Level Security
ALTER TABLE properties ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only access properties in their office
CREATE POLICY tenant_isolation_policy ON properties
  FOR ALL
  USING (office_id = current_setting('app.current_office_id')::UUID);

-- Helper Function to Set Office Context
CREATE OR REPLACE FUNCTION set_office_context(p_office_id UUID)
RETURNS VOID AS $$
BEGIN
  PERFORM set_config('app.current_office_id', p_office_id::TEXT, FALSE);
END;
$$ LANGUAGE plpgsql;
```

---

##### **Level 2: Application-Level Scoping (NestJS)**

**Tenant Interceptor (Auto-Inject `office_id`):**

```typescript
// api/src/common/interceptors/tenant.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class TenantInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    
    // Extract office_id from JWT payload
    const officeId = request.user?.office_id || request.user?.officeId;
    
    if (!officeId) {
      throw new UnauthorizedException('Office ID not found in token');
    }

    // Inject office_id into request for all downstream operations
    request.officeId = officeId;

    // Set PostgreSQL session variable (for RLS policies)
    this.setDatabaseContext(officeId);

    return next.handle();
  }

  private async setDatabaseContext(officeId: string): Promise<void> {
    // This will be executed before every database query
    // Enables Row-Level Security policies
    const supabase = this.supabaseService.getClient();
    await supabase.rpc('set_office_context', { p_office_id: officeId });
  }
}
```

**Apply Interceptor Globally:**

```typescript
// api/src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { TenantInterceptor } from './common/interceptors/tenant.interceptor';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Global Multi-Tenancy Interceptor
  app.useGlobalInterceptors(new TenantInterceptor());

  await app.listen(3001);
}
bootstrap();
```

**Service-Level Enforcement:**

```typescript
// api/src/properties/properties.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { SupabaseService } from '../supabase/supabase.service';

@Injectable()
export class PropertiesService {
  constructor(private readonly supabaseService: SupabaseService) {}

  async findAll(officeId: string, filters: any): Promise<any> {
    const supabase = this.supabaseService.getClient();

    // CRITICAL: Always scope by office_id
    let query = supabase
      .from('properties')
      .select('*')
      .eq('office_id', officeId) // Multi-Tenancy Enforcement
      .is('deleted_at', null);   // Soft delete filter

    // Apply additional filters
    if (filters.propertyType) {
      query = query.eq('property_type', filters.propertyType);
    }

    if (filters.minPrice) {
      query = query.gte('price', filters.minPrice);
    }

    const { data, error } = await query;

    if (error) throw error;
    return data;
  }

  async findOne(officeId: string, propertyId: string): Promise<any> {
    const supabase = this.supabaseService.getClient();

    const { data, error } = await supabase
      .from('properties')
      .select('*')
      .eq('id', propertyId)
      .eq('office_id', officeId) // Multi-Tenancy Enforcement
      .is('deleted_at', null)
      .single();

    if (error || !data) {
      throw new NotFoundException('العقار غير موجود');
    }

    return data;
  }

  async create(officeId: string, userId: string, dto: CreatePropertyDto): Promise<any> {
    const supabase = this.supabaseService.getClient();

    // Auto-inject office_id on creation
    const { data, error } = await supabase
      .from('properties')
      .insert({
        ...dto,
        office_id: officeId, // CRITICAL: Always inject office_id
        created_by: userId
      })
      .select()
      .single();

    if (error) throw error;
    return data;
  }
}
```

---

##### **Level 3: Frontend State Isolation**

**Zustand Store للحالة العامة:**

```typescript
// Web/src/store/authStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface AuthState {
  user: {
    id: string;
    office_id: string; // Critical for Multi-Tenancy
    role: string;
    name: string;
    email: string;
  } | null;
  accessToken: string | null;
  setAuth: (user: any, accessToken: string) => void;
  clearAuth: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      accessToken: null,
      
      setAuth: (user, accessToken) => {
        // Validate that user has office_id
        if (!user.office_id) {
          throw new Error('User must belong to an office (Multi-Tenancy violation)');
        }
        set({ user, accessToken });
      },

      clearAuth: () => set({ user: null, accessToken: null })
    }),
    {
      name: 'auth-storage'
    }
  )
);
```

**API Client مع Auto-Scoping:**

```typescript
// Web/src/lib/api/properties.ts
import api from '../axios';
import { useAuthStore } from '@/store/authStore';

export const propertiesApi = {
  getAll: async (filters: any) => {
    const user = useAuthStore.getState().user;
    
    // Multi-Tenancy: Automatically scoped by JWT
    // Backend will extract office_id from token
    const { data } = await api.get('/api/properties', { params: filters });
    return data;
  },

  getOne: async (id: string) => {
    const { data } = await api.get(`/api/properties/${id}`);
    return data;
  },

  create: async (propertyData: any) => {
    // No need to manually add office_id - backend extracts from JWT
    const { data } = await api.post('/api/properties', propertyData);
    return data;
  }
};
```

---

##### **Level 4: File Storage Isolation**

**S3/Object Storage Structure:**

```
s3://real-estate-bucket/
├── office_94d768f1-2bcb-4a2a-9782-6f1e4bc9440c/
│   ├── properties/
│   │   ├── prop_abc123_image1.jpg
│   │   └── prop_abc123_image2.jpg
│   ├── contracts/
│   │   └── contract_xyz789.pdf
│   └── invoices/
│       └── invoice_2024_001.pdf
├── office_12345678-1234-1234-1234-123456789012/
│   ├── properties/
│   │   └── prop_def456_image1.jpg
│   └── contracts/
│       └── contract_abc123.pdf
```

**حل الملاحظة #4 (Property Image Upload - 404 Error):**

**المشكلة الحالية:**
```
POST /api/properties/upload -> 404 Not Found
```

**السبب:**
Endpoint غير موجود في `properties.controller.ts`.

**الحل الكامل:**

```typescript
// api/src/properties/properties.controller.ts
import { 
  Controller, Post, UseInterceptors, UploadedFiles, 
  Req, BadRequestException, UseGuards 
} from '@nestjs/common';
import { FilesInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { extname } from 'path';
import { Roles } from '../auth/roles.decorator';
import { RolesGuard } from '../auth/roles.guard';
import { PropertiesService } from './properties.service';

@Controller('properties')
@UseGuards(RolesGuard)
export class PropertiesController {
  constructor(private readonly propertiesService: PropertiesService) {}

  // ✅ حل الملاحظة #4: Property Image Upload Endpoint
  @Post('upload')
  @Roles('system_admin', 'office_admin', 'manager', 'staff')
  @UseInterceptors(
    FilesInterceptor('files', 10, {
      storage: diskStorage({
        destination: './uploads/properties',
        filename: (req, file, callback) => {
          const officeId = req.user?.office_id || req.user?.officeId;
          const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
          const ext = extname(file.originalname);
          // Multi-Tenancy: Include office_id in filename
          const filename = `${officeId}_${uniqueSuffix}${ext}`;
          callback(null, filename);
        }
      }),
      fileFilter: (req, file, callback) => {
        // Validate file type (images only)
        if (!file.mimetype.match(/\/(jpg|jpeg|png|webp)$/)) {
          return callback(
            new BadRequestException('يجب أن يكون الملف صورة (JPG, PNG, WEBP)'),
            false
          );
        }
        callback(null, true);
      },
      limits: {
        fileSize: 5 * 1024 * 1024 // 5MB max per file
      }
    })
  )
  async uploadPropertyImages(
    @Req() req: any,
    @UploadedFiles() files: Express.Multer.File[]
  ): Promise<any> {
    const officeId = req.user?.office_id || req.user?.officeId;

    if (!files || files.length === 0) {
      throw new BadRequestException('لم يتم رفع أي ملفات');
    }

    // Generate public URLs for uploaded files
    const imageUrls = files.map(file => ({
      url: `/uploads/properties/${file.filename}`,
      filename: file.filename,
      size: file.size,
      mimetype: file.mimetype
    }));

    return {
      success: true,
      message: `تم رفع ${files.length} صورة بنجاح`,
      images: imageUrls
    };
  }

  // Alternative: Upload to S3/Cloud Storage
  @Post('upload-cloud')
  @Roles('system_admin', 'office_admin', 'manager', 'staff')
  @UseInterceptors(FilesInterceptor('files', 10))
  async uploadToCloud(
    @Req() req: any,
    @UploadedFiles() files: Express.Multer.File[]
  ): Promise<any> {
    const officeId = req.user?.office_id || req.user?.officeId;

    if (!files || files.length === 0) {
      throw new BadRequestException('لم يتم رفع أي ملفات');
    }

    // Upload to S3 with Multi-Tenancy path
    const uploadPromises = files.map(file =>
      this.propertiesService.uploadToS3(officeId, file)
    );

    const uploadedFiles = await Promise.all(uploadPromises);

    return {
      success: true,
      message: `تم رفع ${files.length} صورة إلى السحابة بنجاح`,
      images: uploadedFiles
    };
  }
}
```

**Properties Service - S3 Upload:**

```typescript
// api/src/properties/properties.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { S3 } from 'aws-sdk';

@Injectable()
export class PropertiesService {
  private s3: S3;

  constructor(private readonly configService: ConfigService) {
    this.s3 = new S3({
      accessKeyId: this.configService.get('AWS_ACCESS_KEY_ID'),
      secretAccessKey: this.configService.get('AWS_SECRET_ACCESS_KEY'),
      region: this.configService.get('AWS_REGION', 'me-south-1') // PDPL: Saudi region
    });
  }

  async uploadToS3(officeId: string, file: Express.Multer.File): Promise<any> {
    const bucket = this.configService.get('AWS_S3_BUCKET');
    const ext = extname(file.originalname);
    const key = `${officeId}/properties/${Date.now()}-${Math.random().toString(36).substring(7)}${ext}`;

    const uploadResult = await this.s3.upload({
      Bucket: bucket,
      Key: key,
      Body: file.buffer,
      ContentType: file.mimetype,
      ACL: 'private' // Multi-Tenancy: Private by default
    }).promise();

    // Generate pre-signed URL (expires in 1 hour)
    const signedUrl = this.s3.getSignedUrl('getObject', {
      Bucket: bucket,
      Key: key,
      Expires: 3600
    });

    return {
      key,
      url: uploadResult.Location,
      signedUrl,
      bucket
    };
  }

  async getPropertyImages(officeId: string, propertyId: string): Promise<any[]> {
    const supabase = this.supabaseService.getClient();

    const { data, error } = await supabase
      .from('property_images')
      .select('*')
      .eq('property_id', propertyId)
      .eq('office_id', officeId); // Multi-Tenancy

    if (error) throw error;

    // Generate fresh signed URLs for each image
    const imagesWithSignedUrls = await Promise.all(
      data.map(async (img) => ({
        ...img,
        signedUrl: this.s3.getSignedUrl('getObject', {
          Bucket: this.configService.get('AWS_S3_BUCKET'),
          Key: img.s3_key,
          Expires: 3600
        })
      }))
    );

    return imagesWithSignedUrls;
  }
}
```

**Frontend Implementation:**

```typescript
// Web/src/components/properties/PropertyImageUpload.tsx
import { useState } from 'react';
import axios from 'axios';

export const PropertyImageUpload = ({ propertyId }: { propertyId: string }) => {
  const [uploading, setUploading] = useState(false);
  const [uploadedImages, setUploadedImages] = useState<string[]>([]);

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;

    setUploading(true);

    const formData = new FormData();
    Array.from(e.target.files).forEach(file => {
      formData.append('files', file);
    });

    try {
      const { data } = await axios.post('/api/properties/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });

      setUploadedImages(data.images.map((img: any) => img.url));
      alert(`تم رفع ${data.images.length} صورة بنجاح`);
    } catch (error) {
      console.error('Error uploading files:', error);
      alert('فشل رفع الصور');
    } finally {
      setUploading(false);
    }
  };

  return (
    <div className="space-y-4">
      <label className="block">
        <span className="text-sm font-medium">رفع صور العقار</span>
        <input
          type="file"
          multiple
          accept="image/jpeg,image/png,image/webp"
          onChange={handleFileUpload}
          disabled={uploading}
          className="mt-1 block w-full text-sm text-gray-500
            file:mr-4 file:py-2 file:px-4
            file:rounded-full file:border-0
            file:text-sm file:font-semibold
            file:bg-blue-50 file:text-blue-700
            hover:file:bg-blue-100"
        />
      </label>

      {uploading && <p className="text-sm text-gray-600">جاري رفع الصور...</p>}

      {uploadedImages.length > 0 && (
        <div className="grid grid-cols-3 gap-4">
          {uploadedImages.map((url, index) => (
            <img
              key={index}
              src={url}
              alt={`Property ${index + 1}`}
              className="w-full h-32 object-cover rounded-lg"
            />
          ))}
        </div>
      )}
    </div>
  );
};
```

---

### 3.2 نظام RBAC الكامل (Role-Based Access Control)

#### 3.2.1 جدول الصلاحيات الشامل (Complete RBAC Matrix)

**تعريف الأدوار الثمانية (8 Roles):**

```typescript
// api/src/auth/roles.decorator.ts
export type AppRole = 
  | 'system_admin'    // مدير النظام الكلي
  | 'office_admin'    // مدير المكتب (مالك المكتب)
  | 'manager'         // مدير العمليات
  | 'staff'           // موظف عادي
  | 'accountant'      // محاسب
  | 'technician'      // فني صيانة
  | 'owner'           // مالك عقار (عميل خارجي)
  | 'tenant';         // مستأجر (عميل خارجي)
```

**المصفوفة الكاملة (Complete Permission Matrix):**

| **Module/Feature** | **system_admin** | **office_admin** | **manager** | **staff** | **accountant** | **technician** | **owner** | **tenant** |
|---|---|---|---|---|---|---|---|---|
| **Offices Management** |  |  |  |  |  |  |  |  |
| Create Office | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| View All Offices | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Edit Any Office | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Delete Office | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Edit Own Office | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| **User Management** |  |  |  |  |  |  |  |  |
| Create User (Any Office) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Create User (Own Office) | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Activate User | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Deactivate User | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Edit User Permissions | ✅ | ✅ (Own Office) | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Delete User | ✅ | ✅ (Own Office) | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| View Audit Logs | ✅ | ✅ (Own Office) | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| **Properties** |  |  |  |  |  |  |  |  |
| View Properties | ✅ | ✅ | ✅ | ✅ | ✅ (Limited) | ✅ (Assigned) | ✅ (Own) | ✅ (Rented) |
| Create Property | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ (Own) | ❌ |
| Edit Property | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ (Own) | ❌ |
| Delete Property | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Upload Property Images | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ (Own) | ❌ |
| Export Properties | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ✅ (Own) | ❌ |
| Import Properties (Excel) | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| **Customers** |  |  |  |  |  |  |  |  |
| View Customers | ✅ | ✅ | ✅ | ✅ | ✅ (Limited) | ❌ | ❌ | ❌ |
| Create Customer | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ |
| Edit Customer | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ |
| Delete Customer | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| View Customer Financial Data | ✅ | ✅ | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ |
| Export Customers | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ |
| **Appointments** |  |  |  |  |  |  |  |  |
| View Appointments | ✅ | ✅ | ✅ | ✅ | ❌ | ✅ (Assigned) | ✅ (Own) | ✅ (Own) |
| Create Appointment | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ | ✅ |
| Edit Appointment | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ (Own) | ✅ (Own) |
| Delete Appointment | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| **Contracts** |  |  |  |  |  |  |  |  |
| View Contracts | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ✅ (Own) | ✅ (Own) |
| Create Contract | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Edit Contract | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Terminate Contract | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Export Contract PDF | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ✅ (Own) | ✅ (Own) |
| Register with Ejar | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| **Financial/Payments** |  |  |  |  |  |  |  |  |
| View Payments | ✅ | ✅ | ✅ | ❌ | ✅ | ❌ | ✅ (Own) | ✅ (Own) |
| Record Payment | ✅ | ✅ | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ |
| Generate Invoice | ✅ | ✅ | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ |
| View Financial Reports | ✅ | ✅ | ✅ | ❌ | ✅ | ❌ | ✅ (Own) | ❌ |
| Export Financial Data | ✅ | ✅ | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ |
| **Maintenance** |  |  |  |  |  |  |  |  |
| View Maintenance Requests | ✅ | ✅ | ✅ | ✅ | ❌ | ✅ | ✅ (Own) | ✅ (Own) |
| Create Maintenance Request | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ | ✅ |
| Assign Technician | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Update Request Status | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ (Assigned) | ❌ | ❌ |
| Close Request | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ (Assigned) | ❌ | ❌ |
| **Analytics/Dashboard** |  |  |  |  |  |  |  |  |
| View Dashboard | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ (Limited) | ✅ (Own) | ✅ (Own) |
| View Advanced Analytics | ✅ | ✅ | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ |
| Export Analytics Report | ✅ | ✅ | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ |
| **System Settings** |  |  |  |  |  |  |  |  |
| View System Settings | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Edit System Settings | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| View Office Settings | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Edit Office Settings | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |

---

#### 3.2.2 تطبيق الصلاحيات المتقدمة (Advanced Permissions)

**حل الملاحظة #8: Granular Column & Row Permissions**

**Database Schema للصلاحيات المخصصة:**

```sql
-- Custom Permissions Structure (Stored in user_permissions.permissions JSONB)
CREATE TYPE permission_level AS ENUM ('none', 'read', 'write', 'full');

-- Example permissions JSONB structure
{
  "properties": {
    "access": "full",  -- 'none', 'read', 'write', 'full'
    "fields": {
      "title": "read",
      "price": "none",  -- Cannot see price column
      "owner_name": "read",
      "city": "full"
    },
    "actions": {
      "create": true,
      "edit": true,
      "delete": false,
      "export": true
    }
  },
  "customers": {
    "access": "read",
    "fields": {
      "name": "read",
      "phone": "read",
      "national_id": "none",  -- Cannot see national ID
      "budget": "none"
    },
    "actions": {
      "create": false,
      "edit": false,
      "delete": false,
      "export": true
    }
  },
  "contracts": {
    "access": "none"  -- No access to contracts module
  }
}
```

**Backend Guard للتحقق من الصلاحيات:**

```typescript
// api/src/auth/permissions.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

export const PERMISSION_KEY = 'permission';
export const Permission = (module: string, action: string) => 
  SetMetadata(PERMISSION_KEY, { module, action });

@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredPermission = this.reflector.getAllAndOverride<{ module: string, action: string }>(
      PERMISSION_KEY,
      [context.getHandler(), context.getClass()]
    );

    if (!requiredPermission) {
      return true; // No specific permission required
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    // Check role-based permissions first
    if (this.hasRolePermission(user.role, requiredPermission)) {
      return true;
    }

    // Check custom permissions (JSONB)
    if (this.hasCustomPermission(user.permissions, requiredPermission)) {
      return true;
    }

    throw new ForbiddenException(
      `ليس لديك الصلاحية لتنفيذ هذه العملية (${requiredPermission.module}.${requiredPermission.action})`
    );
  }

  private hasRolePermission(role: string, permission: { module: string, action: string }): boolean {
    const rolePermissions = {
      'system_admin': ['*'], // Full access to everything
      'office_admin': ['properties.*', 'customers.*', 'appointments.*', 'contracts.*', 'users.create', 'users.edit'],
      'manager': ['properties.*', 'customers.*', 'appointments.*', 'contracts.*'],
      'staff': ['properties.read', 'properties.write', 'customers.read', 'customers.write', 'appointments.*'],
      'accountant': ['properties.read', 'customers.read', 'contracts.read', 'payments.*', 'reports.*']
    };

    const allowedPermissions = rolePermissions[role] || [];

    return allowedPermissions.includes('*') ||
           allowedPermissions.includes(`${permission.module}.*`) ||
           allowedPermissions.includes(`${permission.module}.${permission.action}`);
  }

  private hasCustomPermission(customPermissions: any, permission: { module: string, action: string }): boolean {
    if (!customPermissions || typeof customPermissions !== 'object') {
      return false;
    }

    const modulePermissions = customPermissions[permission.module];
    if (!modulePermissions) {
      return false;
    }

    // Check if access level allows the action
    if (modulePermissions.access === 'none') {
      return false;
    }

    if (modulePermissions.access === 'full') {
      return true;
    }

    // Check specific action permission
    return modulePermissions.actions?.[permission.action] === true;
  }
}
```

**تطبيق الـ Guard على Controllers:**

```typescript
// api/src/properties/properties.controller.ts
import { Controller, Get, Post, UseGuards } from '@nestjs/common';
import { RolesGuard } from '../auth/roles.guard';
import { PermissionsGuard, Permission } from '../auth/permissions.guard';

@Controller('properties')
@UseGuards(RolesGuard, PermissionsGuard)
export class PropertiesController {
  
  @Get()
  @Permission('properties', 'read')
  async list(@Req() req: any) {
    return this.propertiesService.findAll(req.user.office_id);
  }

  @Post()
  @Permission('properties', 'create')
  async create(@Req() req: any, @Body() dto: CreatePropertyDto) {
    return this.propertiesService.create(req.user.office_id, req.user.id, dto);
  }

  @Delete(':id')
  @Permission('properties', 'delete')
  async delete(@Req() req: any, @Param('id') id: string) {
    return this.propertiesService.softDelete(req.user.office_id, id);
  }
}
```

**Field-Level Filtering (Column Permissions):**

```typescript
// api/src/properties/properties.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class PropertiesService {
  async findAll(officeId: string, user: any): Promise<any> {
    const supabase = this.supabaseService.getClient();

    const { data, error } = await supabase
      .from('properties')
      .select('*')
      .eq('office_id', officeId)
      .is('deleted_at', null);

    if (error) throw error;

    // Apply field-level permissions
    return data.map(property => this.filterFields(property, user));
  }

  private filterFields(property: any, user: any): any {
    const permissions = user.permissions?.properties?.fields || {};

    // If user has full access, return all fields
    if (user.role === 'system_admin' || user.role === 'office_admin') {
      return property;
    }

    // Filter based on field-level permissions
    const filteredProperty = {};

    Object.keys(property).forEach(field => {
      const fieldPermission = permissions[field];

      // If field permission is 'none', exclude it
      if (fieldPermission === 'none') {
        return;
      }

      // If field permission is 'read', 'write', or 'full', include it
      if (fieldPermission === 'read' || fieldPermission === 'write' || fieldPermission === 'full') {
        filteredProperty[field] = property[field];
      }

      // If no specific permission defined, include by default (for backward compatibility)
      if (!fieldPermission) {
        filteredProperty[field] = property[field];
      }
    });

    return filteredProperty;
  }
}
```

---

#### 3.2.3 إدارة المستخدمين من مدير المكتب

**حل الملاحظة #8: Office Manager User Management**

**Endpoint لإدارة المستخدمين:**

```typescript
// api/src/users/users.controller.ts
import { Controller, Get, Post, Patch, Delete, Body, Param, Req, UseGuards } from '@nestjs/common';
import { Roles } from '../auth/roles.decorator';
import { RolesGuard } from '../auth/roles.guard';
import { UsersService } from './users.service';

@Controller('users')
@UseGuards(RolesGuard)
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  // View users in own office
  @Get()
  @Roles('system_admin', 'office_admin')
  async listUsers(@Req() req: any) {
    const officeId = req.user.role === 'system_admin' ? null : req.user.office_id;
    return this.usersService.findAll(officeId);
  }

  // Create user (Office Admin can only create in their office)
  @Post()
  @Roles('system_admin', 'office_admin')
  async createUser(@Req() req: any, @Body() dto: CreateUserDto) {
    const officeId = req.user.role === 'system_admin' ? dto.office_id : req.user.office_id;

    // Validate subscription limit
    if (req.user.role === 'office_admin') {
      await this.usersService.checkUserLimit(officeId);
    }

    return this.usersService.create(officeId, dto);
  }

  // Edit user permissions (Office Admin can only edit users in their office)
  @Patch(':id/permissions')
  @Roles('system_admin', 'office_admin')
  async updatePermissions(@Req() req: any, @Param('id') userId: string, @Body() dto: UpdatePermissionsDto) {
    // Security check: Office Admin can only edit users in their office
    if (req.user.role === 'office_admin') {
      await this.usersService.verifyUserBelongsToOffice(userId, req.user.office_id);
    }

    return this.usersService.updatePermissions(userId, dto);
  }

  // Activate/Deactivate user
  @Patch(':id/status')
  @Roles('system_admin', 'office_admin')
  async toggleUserStatus(@Req() req: any, @Param('id') userId: string, @Body() dto: { is_active: boolean }) {
    // Security check
    if (req.user.role === 'office_admin') {
      await this.usersService.verifyUserBelongsToOffice(userId, req.user.office_id);
    }

    return this.usersService.toggleStatus(userId, dto.is_active);
  }

  // Delete user
  @Delete(':id')
  @Roles('system_admin', 'office_admin')
  async deleteUser(@Req() req: any, @Param('id') userId: string) {
    // Security check
    if (req.user.role === 'office_admin') {
      await this.usersService.verifyUserBelongsToOffice(userId, req.user.office_id);
    }

    return this.usersService.softDelete(userId);
  }
}
```

**Users Service:**

```typescript
// api/src/users/users.service.ts
import { Injectable, ForbiddenException, BadRequestException } from '@nestjs/common';
import { SupabaseService } from '../supabase/supabase.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class UsersService {
  constructor(private readonly supabaseService: SupabaseService) {}

  async findAll(officeId: string | null): Promise<any> {
    const supabase = this.supabaseService.getClient();

    let query = supabase
      .from('user_permissions')
      .select('id, name, email, phone, role, is_active, last_login, created_at');

    // System Admin: See all users across all offices
    // Office Admin: See only users in their office
    if (officeId) {
      query = query.eq('office_id', officeId);
    }

    const { data, error } = await query;

    if (error) throw error;
    return data;
  }

  async create(officeId: string, dto: CreateUserDto): Promise<any> {
    const supabase = this.supabaseService.getClient();

    // Check if user limit reached
    await this.checkUserLimit(officeId);

    // Hash password
    const passwordHash = await bcrypt.hash(dto.password, 10);

    const { data, error } = await supabase
      .from('user_permissions')
      .insert({
        office_id: officeId,
        name: dto.name,
        email: dto.email,
        phone: dto.phone,
        role: dto.role,
        password_hash: passwordHash,
        is_active: false, // Created but not activated (requires admin approval)
        permissions: dto.permissions || {}
      })
      .select()
      .single();

    if (error) throw error;

    return {
      success: true,
      message: 'تم إنشاء المستخدم بنجاح. يجب تفعيل الحساب من قبل المسؤول.',
      user: { ...data, password_hash: undefined }
    };
  }

  async checkUserLimit(officeId: string): Promise<void> {
    const supabase = this.supabaseService.getClient();

    // Get office subscription info
    const { data: office, error: officeError } = await supabase
      .from('offices')
      .select('subscription_plan, max_users')
      .eq('id', officeId)
      .single();

    if (officeError || !office) {
      throw new BadRequestException('المكتب غير موجود');
    }

    // Count active users in office
    const { count, error: countError } = await supabase
      .from('user_permissions')
      .select('*', { count: 'exact', head: true })
      .eq('office_id', officeId)
      .eq('is_active', true);

    if (countError) throw countError;

    if (count >= office.max_users) {
      throw new ForbiddenException(
        `تم تجاوز الحد الأقصى للمستخدمين (${office.max_users}). يرجى الترقية إلى خطة أعلى أو التواصل مع الدعم.`
      );
    }
  }

  async verifyUserBelongsToOffice(userId: string, officeId: string): Promise<void> {
    const supabase = this.supabaseService.getClient();

    const { data: user, error } = await supabase
      .from('user_permissions')
      .select('office_id')
      .eq('id', userId)
      .single();

    if (error || !user) {
      throw new ForbiddenException('المستخدم غير موجود');
    }

    if (user.office_id !== officeId) {
      throw new ForbiddenException('لا يمكنك تعديل مستخدم من مكتب آخر');
    }
  }

  async updatePermissions(userId: string, dto: UpdatePermissionsDto): Promise<any> {
    const supabase = this.supabaseService.getClient();

    const { data, error } = await supabase
      .from('user_permissions')
      .update({
        role: dto.role,
        permissions: dto.permissions
      })
      .eq('id', userId)
      .select()
      .single();

    if (error) throw error;

    return {
      success: true,
      message: 'تم تحديث صلاحيات المستخدم بنجاح',
      user: { ...data, password_hash: undefined }
    };
  }

  async toggleStatus(userId: string, isActive: boolean): Promise<any> {
    const supabase = this.supabaseService.getClient();

    const { data, error } = await supabase
      .from('user_permissions')
      .update({ is_active: isActive })
      .eq('id', userId)
      .select()
      .single();

    if (error) throw error;

    return {
      success: true,
      message: isActive ? 'تم تفعيل المستخدم بنجاح' : 'تم إلغاء تفعيل المستخدم',
      user: { ...data, password_hash: undefined }
    };
  }

  async softDelete(userId: string): Promise<any> {
    const supabase = this.supabaseService.getClient();

    const { error } = await supabase
      .from('user_permissions')
      .update({ is_active: false, deleted_at: new Date().toISOString() })
      .eq('id', userId);

    if (error) throw error;

    return {
      success: true,
      message: 'تم حذف المستخدم بنجاح'
    };
  }
}
```

---

### 3.3 حل المشاكل الفنية من ملاحظات المستخدم

#### 3.3.1 حل الملاحظة #5 (Export Error - 401 Unauthorized)

**المشكلة:**
```
GET /api/properties/export?fields[]=title&fields[]=price
401 Unauthorized: "رمز الدخول منتهي أو غير صالح"
```

**السبب:**
Export endpoint لا يتعامل مع silent token refresh بشكل صحيح عند استخدام query parameters.

**الحل الكامل:**

```typescript
// api/src/properties/properties.controller.ts
import { Controller, Get, Query, Req, Res, UseGuards, StreamableFile } from '@nestjs/common';
import { Response } from 'express';
import * as ExcelJS from 'exceljs';
import { Roles } from '../auth/roles.decorator';
import { RolesGuard } from '../auth/roles.guard';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';

@Controller('properties')
@UseGuards(JwtAuthGuard, RolesGuard) // Ensure JWT is validated first
export class PropertiesController {
  
  // ✅ حل الملاحظة #5: Export with Proper Authentication
  @Get('export')
  @Roles('system_admin', 'office_admin', 'manager', 'staff', 'accountant')
  async exportProperties(
    @Req() req: any,
    @Query('fields') fields: string[],
    @Res({ passthrough: true }) res: Response
  ): Promise<StreamableFile> {
    const officeId = req.user?.office_id || req.user?.officeId;

    if (!officeId) {
      throw new UnauthorizedException('يجب تسجيل الدخول لتصدير البيانات');
    }

    // Fetch properties
    const properties = await this.propertiesService.findAll(officeId, {});

    // Generate Excel file
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('العقارات');

    // Define columns based on requested fields
    const allFields = {
      'title': 'العنوان',
      'property_type': 'نوع العقار',
      'listing_type': 'نوع الإعلان',
      'price': 'السعر',
      'city': 'المدينة',
      'district': 'الحي',
      'bedrooms': 'عدد الغرف',
      'bathrooms': 'عدد الحمامات',
      'area': 'المساحة',
      'status': 'الحالة'
    };

    // Filter columns based on requested fields
    const selectedFields = fields && fields.length > 0 
      ? fields 
      : Object.keys(allFields);

    worksheet.columns = selectedFields.map(field => ({
      header: allFields[field] || field,
      key: field,
      width: 20
    }));

    // Add rows
    properties.forEach(property => {
      const row = {};
      selectedFields.forEach(field => {
        row[field] = property[field] || '';
      });
      worksheet.addRow(row);
    });

    // Style header row
    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' }
    };

    // Generate buffer
    const buffer = await workbook.xlsx.writeBuffer();

    // Set response headers
    res.set({
      'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'Content-Disposition': `attachment; filename="properties_${Date.now()}.xlsx"`,
      'Content-Length': buffer.length
    });

    return new StreamableFile(Buffer.from(buffer));
  }
}
```

**Frontend Fix (Token Handling):**

```typescript
// Web/src/lib/api/properties.ts
import api from '../axios';

export const propertiesApi = {
  export: async (fields: string[]) => {
    try {
      const params = new URLSearchParams();
      fields.forEach(field => params.append('fields[]', field));

      const response = await api.get(`/api/properties/export?${params.toString()}`, {
        responseType: 'blob' // Important for file download
      });

      // Create download link
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `properties_${Date.now()}.xlsx`);
      document.body.appendChild(link);
      link.click();
      link.remove();

      return { success: true };
    } catch (error) {
      // The Axios interceptor will handle 401 and retry with refreshed token
      console.error('Export error:', error);
      throw error;
    }
  }
};
```

---

#### 3.3.2 حل الملاحظة #6 (Import Error - Select.Item Empty Value)

**المشكلة:**
```
Error: A <Select.Item /> must have a value prop that is not an empty string.
```

**السبب:**
Component `ColumnMatcher` في الـ Import UI يحاول رسم `<Select.Item>` بقيمة فارغة.

**الحل:**

```typescript
// Web/src/components/properties/ImportProperties.tsx
import { useState } from 'react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import * as XLSX from 'xlsx';

export const ImportProperties = () => {
  const [excelColumns, setExcelColumns] = useState<string[]>([]);
  const [columnMapping, setColumnMapping] = useState<Record<string, string>>({});

  const systemFields = [
    { value: 'title', label: 'العنوان' },
    { value: 'property_type', label: 'نوع العقار' },
    { value: 'listing_type', label: 'نوع الإعلان' },
    { value: 'price', label: 'السعر' },
    { value: 'city', label: 'المدينة' },
    { value: 'district', label: 'الحي' },
    { value: 'bedrooms', label: 'عدد الغرف' },
    { value: 'bathrooms', label: 'عدد الحمامات' },
    { value: 'area', label: 'المساحة (م²)' }
  ];

  const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      const data = new Uint8Array(event.target?.result as ArrayBuffer);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

      // Extract first row as headers
      const headers = (jsonData[0] as string[]).filter(h => h && h.trim() !== ''); // ✅ Filter empty values
      setExcelColumns(headers);

      // Auto-match columns based on similarity
      const autoMapping = autoMatchColumns(headers, systemFields);
      setColumnMapping(autoMapping);
    };

    reader.readAsArrayBuffer(file);
  };

  const autoMatchColumns = (excelCols: string[], systemCols: typeof systemFields): Record<string, string> => {
    const mapping: Record<string, string> = {};

    excelCols.forEach(excelCol => {
      const normalizedExcelCol = excelCol.toLowerCase().trim();

      // Find best match using Levenshtein distance or exact match
      const bestMatch = systemCols.find(sysCol => {
        const normalizedSysLabel = sysCol.label.toLowerCase();
        return normalizedSysLabel.includes(normalizedExcelCol) || 
               normalizedExcelCol.includes(normalizedSysLabel);
      });

      if (bestMatch) {
        mapping[excelCol] = bestMatch.value;
      }
    });

    return mapping;
  };

  return (
    <div className="space-y-6">
      <h2 className="text-2xl font-bold">استيراد العقارات من Excel</h2>

      <div>
        <label className="block text-sm font-medium mb-2">
          اختر ملف Excel
        </label>
        <input
          type="file"
          accept=".xlsx,.xls"
          onChange={handleFileUpload}
          className="block w-full text-sm text-gray-500
            file:mr-4 file:py-2 file:px-4
            file:rounded-full file:border-0
            file:text-sm file:font-semibold
            file:bg-blue-50 file:text-blue-700
            hover:file:bg-blue-100"
        />
      </div>

      {excelColumns.length > 0 && (
        <div>
          <h3 className="text-lg font-semibold mb-4">مطابقة الأعمدة</h3>
          <div className="space-y-3">
            {excelColumns.map(excelCol => (
              <div key={excelCol} className="flex items-center gap-4">
                <div className="w-1/3">
                  <span className="text-sm font-medium">{excelCol}</span>
                </div>
                <div className="w-1/3">
                  <Select
                    value={columnMapping[excelCol] || 'skip'} // ✅ Default to 'skip' instead of empty string
                    onValueChange={(value) => {
                      setColumnMapping(prev => ({
                        ...prev,
                        [excelCol]: value
                      }));
                    }}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="اختر حقل" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="skip">تخطي</SelectItem> {/* ✅ Added "Skip" option */}
                      {systemFields.map(field => (
                        <SelectItem key={field.value} value={field.value}>
                          {field.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
```

---

#### 3.3.3 حل الملاحظة #9 (Customers Tab Error - "property tags should not exist")

**المشكلة:**
```
GET /api/customers?page=1&limit=20&search=&tags=
400 Bad Request: "property tags should not exist"
```

**السبب:**
Frontend يرسل query parameter `tags` ولكن الـ DTO الخاص بـ Customers لا يقبل هذا الحقل.

**الحل:**

```typescript
// api/src/customers/dto/filter-customers.dto.ts
import { IsOptional, IsString, IsInt, Min, IsArray } from 'class-validator';
import { Type } from 'class-transformer';

export class FilterCustomersDto {
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  limit?: number = 20;

  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @IsString()
  status?: string; // 'new', 'contacted', 'interested', 'not_interested', 'converted'

  @IsOptional()
  @IsString()
  type?: string; // 'individual', 'corporate'

  // ✅ Remove or ignore 'tags' field if it's sent accidentally
  // Do NOT include @IsArray() or validation for 'tags'
}
```

**Frontend Fix:**

```typescript
// Web/src/lib/api/customers.ts
import api from '../axios';

export const customersApi = {
  getAll: async (filters: { page?: number; limit?: number; search?: string; status?: string; type?: string }) => {
    // ✅ Don't send 'tags' parameter
    const cleanedFilters = {
      page: filters.page || 1,
      limit: filters.limit || 20,
      search: filters.search || '',
      ...(filters.status && { status: filters.status }),
      ...(filters.type && { type: filters.type })
    };

    const { data } = await api.get('/api/customers', { params: cleanedFilters });
    return data;
  }
};
```

---

#### 3.3.4 حل الملاحظة #10 & #11 (Appointments Errors - 403 Forbidden & 401 Unauthorized)

**المشكلة #10:**
```
POST /api/appointments
403 Forbidden: "ليس لديك الصلاحية اللازمة لتنفيذ هذه العملية"
```

**المشكلة #11:**
```
GET /api/appointments?page=1&limit=50&search=
401 Unauthorized: "يجب تسجيل الدخول"
```

**السبب:**
AppointmentsController لا يحتوي على الـ `@Roles` decorator الصحيح.

**الحل:**

```typescript
// api/src/appointments/appointments.controller.ts
import { Controller, Get, Post, Patch, Delete, Body, Param, Query, Req, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { Roles } from '../auth/roles.decorator';
import { RolesGuard } from '../auth/roles.guard';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { AppointmentsService } from './appointments.service';

@ApiTags('Appointments')
@ApiBearerAuth()
@Controller('appointments')
@UseGuards(JwtAuthGuard, RolesGuard) // ✅ Ensure both guards are applied
export class AppointmentsController {
  constructor(private readonly appointmentsService: AppointmentsService) {}

  // ✅ حل الملاحظة #11: Get appointments with proper auth
  @Get()
  @Roles('system_admin', 'office_admin', 'manager', 'staff') // ✅ Added roles
  async list(@Req() req: any, @Query() query: any) {
    const officeId = req.user?.office_id || req.user?.officeId;
    
    if (!officeId) {
      throw new UnauthorizedException('يجب تسجيل الدخول للوصول إلى المواعيد');
    }

    return this.appointmentsService.findAll(officeId, query);
  }

  // ✅ حل الملاحظة #10: Create appointment with proper roles
  @Post()
  @Roles('system_admin', 'office_admin', 'manager', 'staff') // ✅ Added roles
  async create(@Req() req: any, @Body() dto: CreateAppointmentDto) {
    const officeId = req.user?.office_id || req.user?.officeId;
    const userId = req.user?.id || req.user?.user_id;

    if (!officeId) {
      throw new UnauthorizedException('يجب تسجيل الدخول لإنشاء موعد');
    }

    return this.appointmentsService.create(officeId, userId, dto);
  }

  @Patch(':id')
  @Roles('system_admin', 'office_admin', 'manager', 'staff')
  async update(@Req() req: any, @Param('id') id: string, @Body() dto: UpdateAppointmentDto) {
    const officeId = req.user?.office_id || req.user?.officeId;
    return this.appointmentsService.update(officeId, id, dto);
  }

  @Delete(':id')
  @Roles('system_admin', 'office_admin', 'manager')
  async delete(@Req() req: any, @Param('id') id: string) {
    const officeId = req.user?.office_id || req.user?.officeId;
    return this.appointmentsService.softDelete(officeId, id);
  }
}
```

**Appointments Service:**

```typescript
// api/src/appointments/appointments.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { SupabaseService } from '../supabase/supabase.service';

@Injectable()
export class AppointmentsService {
  constructor(private readonly supabaseService: SupabaseService) {}

  async findAll(officeId: string, filters: any): Promise<any> {
    const supabase = this.supabaseService.getClient();

    let query = supabase
      .from('appointments')
      .select(`
        *,
        properties (id, title, property_type, city),
        customers (id, name, phone)
      `)
      .eq('office_id', officeId) // Multi-Tenancy
      .is('deleted_at', null)
      .order('scheduled_at', { ascending: true });

    // Apply filters
    if (filters.search) {
      query = query.or(`notes.ilike.%${filters.search}%`);
    }

    if (filters.status) {
      query = query.eq('status', filters.status);
    }

    // Pagination
    const page = parseInt(filters.page) || 1;
    const limit = parseInt(filters.limit) || 50;
    const offset = (page - 1) * limit;

    query = query.range(offset, offset + limit - 1);

    const { data, error } = await query;

    if (error) throw error;

    return {
      data,
      meta: {
        page,
        limit,
        total: data.length
      }
    };
  }

  async create(officeId: string, userId: string, dto: CreateAppointmentDto): Promise<any> {
    const supabase = this.supabaseService.getClient();

    const { data, error } = await supabase
      .from('appointments')
      .insert({
        ...dto,
        office_id: officeId, // Multi-Tenancy
        created_by: userId,
        status: 'scheduled'
      })
      .select()
      .single();

    if (error) throw error;

    return {
      success: true,
      message: 'تم إنشاء الموعد بنجاح',
      appointment: data
    };
  }

  async update(officeId: string, appointmentId: string, dto: UpdateAppointmentDto): Promise<any> {
    const supabase = this.supabaseService.getClient();

    const { data, error } = await supabase
      .from('appointments')
      .update(dto)
      .eq('id', appointmentId)
      .eq('office_id', officeId) // Multi-Tenancy
      .select()
      .single();

    if (error || !data) {
      throw new NotFoundException('الموعد غير موجود');
    }

    return {
      success: true,
      message: 'تم تحديث الموعد بنجاح',
      appointment: data
    };
  }

  async softDelete(officeId: string, appointmentId: string): Promise<any> {
    const supabase = this.supabaseService.getClient();

    const { error } = await supabase
      .from('appointments')
      .update({ deleted_at: new Date().toISOString() })
      .eq('id', appointmentId)
      .eq('office_id', officeId);

    if (error) throw error;

    return {
      success: true,
      message: 'تم حذف الموعد بنجاح'
    };
  }
}
```

---

#### 3.3.5 حل الملاحظة #12 (Notification Dismiss Button)

**المشكلة:**
الإشعارات لا يمكن إزالتها من الشاشة.

**الحل:**

```typescript
// Web/src/components/ui/toast.tsx
import { useState, useEffect } from 'react';
import { X } from 'lucide-react';

interface ToastProps {
  message: string;
  type?: 'success' | 'error' | 'info' | 'warning';
  duration?: number;
  onClose?: () => void;
}

export const Toast = ({ message, type = 'info', duration = 5000, onClose }: ToastProps) => {
  const [visible, setVisible] = useState(true);

  useEffect(() => {
    if (duration > 0) {
      const timer = setTimeout(() => {
        handleClose();
      }, duration);

      return () => clearTimeout(timer);
    }
  }, [duration]);

  const handleClose = () => {
    setVisible(false);
    if (onClose) {
      onClose();
    }
  };

  if (!visible) return null;

  const bgColor = {
    success: 'bg-green-500',
    error: 'bg-red-500',
    info: 'bg-blue-500',
    warning: 'bg-yellow-500'
  }[type];

  return (
    <div className={`fixed bottom-4 right-4 z-50 ${bgColor} text-white px-6 py-4 rounded-lg shadow-lg flex items-center gap-4 min-w-[300px] max-w-[500px]`}>
      <span className="flex-1">{message}</span>
      {/* ✅ حل الملاحظة #12: Dismiss button */}
      <button
        onClick={handleClose}
        className="flex-shrink-0 hover:bg-white/20 rounded-full p-1 transition"
        aria-label="إغلاق"
      >
        <X className="w-5 h-5" />
      </button>
    </div>
  );
};

// Toast Container with Multiple Toasts
export const ToastContainer = () => {
  const { toasts, removeToast } = useToastStore();

  return (
    <div className="fixed bottom-4 right-4 z-50 space-y-2">
      {toasts.map(toast => (
        <Toast
          key={toast.id}
          message={toast.message}
          type={toast.type}
          duration={toast.duration}
          onClose={() => removeToast(toast.id)}
        />
      ))}
    </div>
  );
};
```

**Toast Store (Zustand):**

```typescript
// Web/src/store/toastStore.ts
import { create } from 'zustand';

interface Toast {
  id: string;
  message: string;
  type: 'success' | 'error' | 'info' | 'warning';
  duration: number;
}

interface ToastStore {
  toasts: Toast[];
  addToast: (toast: Omit<Toast, 'id'>) => void;
  removeToast: (id: string) => void;
}

export const useToastStore = create<ToastStore>((set) => ({
  toasts: [],
  
  addToast: (toast) => {
    const id = Math.random().toString(36).substring(7);
    set((state) => ({
      toasts: [...state.toasts, { ...toast, id }]
    }));
  },

  removeToast: (id) => {
    set((state) => ({
      toasts: state.toasts.filter(t => t.id !== id)
    }));
  }
}));
```

---

#### 3.3.6 حل الملاحظة #13 & #14 (Favorites & Reports - 404)

**المشكلة:**
```
GET /dashboard/favorites -> 404 Not Found
GET /dashboard/reports -> 404 Not Found
```

**السبب:**
هذه الـ Routes غير موجودة في Frontend Router.

**الحل:**

```typescript
// Web/src/app/dashboard/favorites/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { Star, Trash2 } from 'lucide-react';
import { useAuthStore } from '@/store/authStore';
import api from '@/lib/axios';

export default function FavoritesPage() {
  const [favorites, setFavorites] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const user = useAuthStore(state => state.user);

  useEffect(() => {
    fetchFavorites();
  }, []);

  const fetchFavorites = async () => {
    try {
      const { data } = await api.get('/api/favorites');
      setFavorites(data);
    } catch (error) {
      console.error('Error fetching favorites:', error);
    } finally {
      setLoading(false);
    }
  };

  const removeFavorite = async (id: string) => {
    try {
      await api.delete(`/api/favorites/${id}`);
      setFavorites(prev => prev.filter(f => f.id !== id));
    } catch (error) {
      console.error('Error removing favorite:', error);
    }
  };

  if (loading) {
    return <div className="p-6">جاري التحميل...</div>;
  }

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">المفضلة</h1>
        <span className="text-sm text-gray-600">{favorites.length} عنصر</span>
      </div>

      {favorites.length === 0 ? (
        <div className="text-center py-12">
          <Star className="w-16 h-16 mx-auto text-gray-300 mb-4" />
          <p className="text-gray-600">لا توجد عقارات في المفضلة</p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {favorites.map(favorite => (
            <div key={favorite.id} className="border rounded-lg p-4 hover:shadow-lg transition">
              <div className="flex items-start justify-between mb-3">
                <h3 className="font-semibold text-lg">{favorite.property.title}</h3>
                <button
                  onClick={() => removeFavorite(favorite.id)}
                  className="text-red-500 hover:text-red-700"
                >
                  <Trash2 className="w-5 h-5" />
                </button>
              </div>
              <p className="text-gray-600 text-sm mb-2">{favorite.property.city} - {favorite.property.district}</p>
              <p className="text-blue-600 font-bold">{favorite.property.price} ريال</p>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

```typescript
// Web/src/app/dashboard/reports/page.tsx
'use client';

import { useState } from 'react';
import { BarChart, FileText, Download, Calendar } from 'lucide-react';
import api from '@/lib/axios';

export default function ReportsPage() {
  const [reportType, setReportType] = useState<string>('properties');
  const [dateRange, setDateRange] = useState({ from: '', to: '' });
  const [generating, setGenerating] = useState(false);

  const reportTypes = [
    { value: 'properties', label: 'تقرير العقارات', icon: BarChart },
    { value: 'contracts', label: 'تقرير العقود', icon: FileText },
    { value: 'financial', label: 'التقرير المالي', icon: Download },
    { value: 'customers', label: 'تقرير العملاء', icon: FileText }
  ];

  const generateReport = async () => {
    setGenerating(true);

    try {
      const { data } = await api.post('/api/reports/generate', {
        type: reportType,
        dateRange
      }, {
        responseType: 'blob'
      });

      // Download PDF
      const url = window.URL.createObjectURL(new Blob([data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `${reportType}_report_${Date.now()}.pdf`);
      document.body.appendChild(link);
      link.click();
      link.remove();
    } catch (error) {
      console.error('Error generating report:', error);
      alert('فشل إنشاء التقرير');
    } finally {
      setGenerating(false);
    }
  };

  return (
    <div className="p-6 space-y-6">
      <h1 className="text-2xl font-bold">التقارير والإحصائيات</h1>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {reportTypes.map(type => (
          <button
            key={type.value}
            onClick={() => setReportType(type.value)}
            className={`p-6 border-2 rounded-lg flex flex-col items-center gap-3 transition ${
              reportType === type.value
                ? 'border-blue-500 bg-blue-50'
                : 'border-gray-200 hover:border-blue-300'
            }`}
          >
            <type.icon className="w-8 h-8 text-blue-600" />
            <span className="font-medium">{type.label}</span>
          </button>
        ))}
      </div>

      <div className="bg-white border rounded-lg p-6 space-y-4">
        <h2 className="text-lg font-semibold">فترة التقرير</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium mb-2">من تاريخ</label>
            <input
              type="date"
              value={dateRange.from}
              onChange={(e) => setDateRange(prev => ({ ...prev, from: e.target.value }))}
              className="w-full border rounded-lg px-4 py-2"
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-2">إلى تاريخ</label>
            <input
              type="date"
              value={dateRange.to}
              onChange={(e) => setDateRange(prev => ({ ...prev, to: e.target.value }))}
              className="w-full border rounded-lg px-4 py-2"
            />
          </div>
        </div>
      </div>

      <button
        onClick={generateReport}
        disabled={generating}
        className="bg-blue-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-blue-700 disabled:bg-gray-400 flex items-center gap-2"
      >
        <Download className="w-5 h-5" />
        {generating ? 'جاري الإنشاء...' : 'إنشاء التقرير'}
      </button>
    </div>
  );
}
```

**Backend Endpoints:**

```typescript
// api/src/favorites/favorites.controller.ts
import { Controller, Get, Post, Delete, Body, Param, Req, UseGuards } from '@nestjs/common';
import { Roles } from '../auth/roles.decorator';
import { RolesGuard } from '../auth/roles.guard';

@Controller('favorites')
@UseGuards(RolesGuard)
export class FavoritesController {
  
  @Get()
  @Roles('system_admin', 'office_admin', 'manager', 'staff')
  async list(@Req() req: any) {
    const userId = req.user.id;
    return this.favoritesService.findByUser(userId);
  }

  @Post()
  @Roles('system_admin', 'office_admin', 'manager', 'staff')
  async add(@Req() req: any, @Body() dto: { property_id: string }) {
    const userId = req.user.id;
    return this.favoritesService.add(userId, dto.property_id);
  }

  @Delete(':id')
  @Roles('system_admin', 'office_admin', 'manager', 'staff')
  async remove(@Req() req: any, @Param('id') id: string) {
    return this.favoritesService.remove(id);
  }
}
```

```typescript
// api/src/reports/reports.controller.ts
import { Controller, Post, Body, Req, Res, UseGuards } from '@nestjs/common';
import { Response } from 'express';
import { Roles } from '../auth/roles.decorator';
import { RolesGuard } from '../auth/roles.guard';
import { ReportsService } from './reports.service';

@Controller('reports')
@UseGuards(RolesGuard)
export class ReportsController {
  constructor(private readonly reportsService: ReportsService) {}

  @Post('generate')
  @Roles('system_admin', 'office_admin', 'manager', 'accountant')
  async generateReport(
    @Req() req: any,
    @Body() dto: { type: string; dateRange: { from: string; to: string } },
    @Res() res: Response
  ) {
    const officeId = req.user.office_id;

    const pdfBuffer = await this.reportsService.generatePDF(officeId, dto.type, dto.dateRange);

    res.set({
      'Content-Type': 'application/pdf',
      'Content-Disposition': `attachment; filename="${dto.type}_report_${Date.now()}.pdf"`,
      'Content-Length': pdfBuffer.length
    });

    res.send(pdfBuffer);
  }
}
```

---

## الملاحظات الختامية للجزء الثالث

**ملخص النقاط الرئيسية:**

1. **Multi-Tenancy Architecture (4 Levels):**
   - Database-Level: Row-Level Security (RLS) policies
   - Application-Level: TenantInterceptor + Service-level `office_id` scoping
   - Frontend: Zustand store with `office_id` validation
   - File Storage: S3 paths with `office_id` prefix

2. **RBAC Matrix (8 Roles):**
   - Complete permission matrix for all modules
   - Custom field-level permissions (JSONB)
   - PermissionsGuard for granular access control
   - Office Manager can manage users within their office only

3. **حلول المشاكل الفنية:**
   - ✅ Note #4: Property upload endpoint (`POST /api/properties/upload`)
   - ✅ Note #5: Export with proper authentication
   - ✅ Note #6: Import with fixed Select.Item values
   - ✅ Note #8: Complete user management for Office Admins
   - ✅ Note #9: Customers endpoint fixed (removed 'tags' validation)
   - ✅ Note #10 & #11: Appointments with proper @Roles decorators
   - ✅ Note #12: Toast dismiss button
   - ✅ Note #13 & #14: Favorites & Reports pages created

---

**الخطوة التالية:**
الانتقال إلى **الجزء الرابع: النظرة الفنية (PART IV: TECHNICAL VIEW)** الذي سيفصّل Backend Architecture, Frontend Architecture, Database Design, و Performance Optimization.

---

**تاريخ التحديث:** 19 نوفمبر 2025
**الإصدار:** 3.0 - Part III
**الحالة:** مكتمل ✓

---

# **الجزء الرابع: النظرة الفنية**
## PART IV: TECHNICAL VIEW - The Core Engine

---

## 4. البنية الفنية للنظام

### 4.1 معمارية النظام الشاملة (System Architecture Overview)

#### 4.1.1 النمط المعماري: Layered Architecture + Microservices-Ready

**النظرية (Theory - Why):**

النظام يتبع **Layered Architecture** مع استعداد للتحول إلى Microservices:

1. **Separation of Concerns:** كل طبقة لها مسؤولية واحدة فقط
2. **Maintainability:** سهولة الصيانة والتطوير
3. **Testability:** كل طبقة قابلة للاختبار بشكل مستقل
4. **Scalability:** إمكانية تحويل كل module إلى microservice مستقبلاً

**المثال (Example - What):**

الطبقات الأربع الرئيسية:

```
┌─────────────────────────────────────────────┐
│   Presentation Layer (Next.js 14)          │
│   - UI Components                           │
│   - State Management (Zustand)             │
│   - Client-Side Routing                    │
└─────────────────────────────────────────────┘
                   ↓ HTTPS/REST
┌─────────────────────────────────────────────┐
│   API Gateway Layer (NestJS)               │
│   - Authentication Guards                   │
│   - Rate Limiting                           │
│   - Request Validation                      │
└─────────────────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│   Business Logic Layer (NestJS Services)   │
│   - PropertiesService                       │
│   - ContractsService                        │
│   - AnalyticsService                        │
└─────────────────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│   Data Access Layer (TypeORM + Supabase)   │
│   - Repositories                            │
│   - Database Connections                    │
│   - Caching (Redis)                         │
└─────────────────────────────────────────────┘
```

**المساعدة/الكود (Aid/Code - How):**

**Folder Structure (Exact):**

```
/workspace/
├── api/                          # Backend (NestJS)
│   ├── src/
│   │   ├── main.ts              # Entry point - Port 3001
│   │   ├── app.module.ts        # Root module
│   │   ├── auth/                # Authentication module
│   │   │   ├── auth.module.ts
│   │   │   ├── auth.controller.ts
│   │   │   ├── auth.service.ts
│   │   │   ├── jwt.strategy.ts
│   │   │   ├── roles.guard.ts
│   │   │   └── entities/
│   │   │       └── refresh-token.entity.ts
│   │   ├── properties/          # Properties module
│   │   │   ├── properties.module.ts
│   │   │   ├── properties.controller.ts
│   │   │   ├── properties.service.ts
│   │   │   └── dto/
│   │   │       ├── create-property.dto.ts
│   │   │       └── filter-properties.dto.ts
│   │   ├── analytics/           # Analytics module
│   │   │   ├── analytics.module.ts
│   │   │   ├── analytics.controller.ts
│   │   │   └── analytics.service.ts
│   │   └── common/              # Shared utilities
│   │       ├── interceptors/
│   │       │   ├── tenant.interceptor.ts
│   │       │   └── audit-log.interceptor.ts
│   │       └── guards/
│   │           └── permissions.guard.ts
│   └── package.json
│
└── Web/                         # Frontend (Next.js 14)
    ├── src/
    │   ├── app/                 # App Router
    │   │   ├── layout.tsx
    │   │   ├── page.tsx         # Landing page
    │   │   ├── login/
    │   │   │   └── page.tsx
    │   │   └── dashboard/
    │   │       ├── layout.tsx
    │   │       ├── page.tsx
    │   │       ├── properties/
    │   │       ├── customers/
    │   │       ├── appointments/
    │   │       ├── contracts/
    │   │       ├── analytics/
    │   │       ├── settings/    # حل الملاحظات 15, 16, 17, 21
    │   │       │   ├── page.tsx
    │   │       │   ├── appearance/
    │   │       │   ├── notifications/
    │   │       │   ├── staff/
    │   │       │   ├── integrations/
    │   │       │   └── security/
    │   │       ├── favorites/   # حل الملاحظة 13
    │   │       └── reports/     # حل الملاحظة 14
    │   ├── components/
    │   │   ├── ui/              # Shadcn components
    │   │   └── features/        # Feature-specific components
    │   ├── lib/
    │   │   ├── axios.ts         # API client
    │   │   └── api/             # API functions
    │   │       ├── auth.ts
    │   │       ├── properties.ts
    │   │       └── analytics.ts
    │   └── store/               # Zustand stores
    │       ├── authStore.ts
    │       ├── settingsStore.ts # حل الملاحظة 15
    │       └── toastStore.ts
    └── package.json
```

---

### 4.2 معمارية الأمان والمصادقة (Authentication & Security Architecture)

#### 4.2.1 حل الملاحظة #3: Stateless Authentication with Refresh Token Rotation

**النظرية (Theory - Why):**

**المشكلة:** "عملية تسجيل الدخول تنجح لكن بعد مرور الوقت يطلب تسجيل الدخول مرة أخرى بدل من استعمال refreshToken"

**السبب الجذري:**
النظام يستخدم Access Tokens قصيرة العمر (15 دقيقة) بدون آلية Silent Refresh.

**الحل المعماري:**
استخدام **JWT Refresh Token Rotation** وفقاً لمعايير OWASP:

1. **Access Token:** قصير العمر (15 دقيقة) - يُرسل في Authorization header
2. **Refresh Token:** طويل العمر (7 أيام) - يُخزن في HttpOnly Cookie
3. **Token Rotation:** كل refresh يُنتج refresh token جديد ويُلغي القديم
4. **Refresh Token Reuse Detection:** إذا استُخدم refresh token ملغى، يتم إلغاء جميع tokens للمستخدم

**الفوائد الأمنية (OWASP Standards):**
- **OWASP A02:2021 (Cryptographic Failures):** Tokens مُوقعة بـ HMAC-SHA256
- **OWASP A07:2021 (Identification & Authentication Failures):** Token Rotation يمنع Token Theft
- **NIST SP 800-63B:** Refresh tokens في HttpOnly cookies تمنع XSS attacks

**المثال (Example - What):**

**User Journey (Successful Flow):**

```
┌─────────┐                  ┌──────────┐                 ┌──────────┐
│ Browser │                  │ Frontend │                 │ Backend  │
└─────────┘                  └──────────┘                 └──────────┘
     │                             │                            │
     │ 1. User clicks "Login"      │                            │
     ├────────────────────────────>│                            │
     │                             │                            │
     │                             │ 2. POST /api/auth/login    │
     │                             │   { phone, password }      │
     │                             ├──────────────────────────>│
     │                             │                            │
     │                             │                            │ 3. Validate credentials
     │                             │                            │    bcrypt.compare(password, hash)
     │                             │                            │
     │                             │  4. Response:              │
     │                             │    - accessToken (15min)   │
     │                             │    - Set-Cookie: refresh_  │
     │                             │      token (HttpOnly)      │
     │                             │<──────────────────────────│
     │                             │                            │
     │ 5. Store accessToken in     │                            │
     │    localStorage             │                            │
     │<────────────────────────────│                            │
     │                             │                            │
     │ 6. Make API request         │                            │
     │    Authorization: Bearer    │                            │
     │    {accessToken}            │                            │
     ├────────────────────────────>│──────────────────────────>│
     │                             │                            │
     │                             │  7. Response: 200 OK       │
     │<────────────────────────────│<──────────────────────────│
     │                             │                            │
     │ ... 16 minutes later ...    │                            │
     │                             │                            │
     │ 8. Make API request         │                            │
     │    (accessToken expired)    │                            │
     ├────────────────────────────>│──────────────────────────>│
     │                             │                            │
     │                             │  9. Response: 401          │
     │                             │     "Token expired"        │
     │                             │<──────────────────────────│
     │                             │                            │
     │                             │ 10. Axios interceptor      │
     │                             │     detects 401            │
     │                             │                            │
     │                             │ 11. POST /api/auth/refresh │
     │                             │     (sends HttpOnly cookie)│
     │                             ├──────────────────────────>│
     │                             │                            │
     │                             │                            │ 12. Verify refresh token
     │                             │                            │     Check DB for revocation
     │                             │                            │     Generate new tokens
     │                             │                            │
     │                             │  13. Response:             │
     │                             │     - new accessToken      │
     │                             │     - new refresh_token    │
     │                             │       (rotate old one)     │
     │                             │<──────────────────────────│
     │                             │                            │
     │                             │ 14. Retry original request │
     │                             │     with new accessToken   │
     │                             ├──────────────────────────>│
     │                             │                            │
     │                             │  15. Response: 200 OK      │
     │<────────────────────────────│<──────────────────────────│
```

**المساعدة/الكود (Aid/Code - How):**

**1. Database Schema (RefreshToken Entity):**

```typescript
// api/src/auth/entities/refresh-token.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  Index,
  ManyToOne,
  JoinColumn
} from 'typeorm';

@Entity('refresh_tokens')
export class RefreshToken {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Index()
  @Column({ type: 'uuid' })
  user_id: string;

  // Store bcrypt hash of the token (not the token itself)
  @Column({ type: 'varchar', length: 255 })
  token_hash: string;

  @Index()
  @Column({ type: 'timestamp' })
  expires_at: Date;

  // Device fingerprinting for security
  @Column({ type: 'jsonb', nullable: true })
  device_info: {
    userAgent?: string;
    platform?: string;
    browser?: string;
  };

  @Column({ type: 'varchar', nullable: true })
  ip_address: string;

  @Column({ type: 'varchar', nullable: true })
  user_agent: string;

  // Revocation flags
  @Column({ type: 'boolean', default: false })
  is_revoked: boolean;

  @Column({ type: 'timestamp', nullable: true })
  revoked_at: Date;

  // If this token was used to create a new token (rotation)
  @Column({ type: 'uuid', nullable: true })
  rotated_to: string;

  @Index()
  @CreateDateColumn()
  created_at: Date;

  // Composite indexes for performance
  @Index(['user_id', 'expires_at'])
  composite_user_expires?: void;

  @Index(['user_id', 'is_revoked'])
  composite_user_revoked?: void;
}
```

**SQL Migration:**

```sql
-- Create refresh_tokens table
CREATE TABLE refresh_tokens (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES user_permissions(id) ON DELETE CASCADE,
  token_hash VARCHAR(255) NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  device_info JSONB,
  ip_address VARCHAR(45),
  user_agent TEXT,
  is_revoked BOOLEAN DEFAULT false,
  revoked_at TIMESTAMP,
  rotated_to UUID REFERENCES refresh_tokens(id),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Performance indexes
CREATE INDEX idx_refresh_user ON refresh_tokens(user_id);
CREATE INDEX idx_refresh_expires ON refresh_tokens(expires_at);
CREATE INDEX idx_refresh_user_expires ON refresh_tokens(user_id, expires_at);
CREATE INDEX idx_refresh_user_revoked ON refresh_tokens(user_id, is_revoked);

-- Cleanup expired tokens (run daily via cron)
CREATE OR REPLACE FUNCTION cleanup_expired_refresh_tokens()
RETURNS void AS $$
BEGIN
  DELETE FROM refresh_tokens
  WHERE expires_at < NOW() - INTERVAL '30 days';
END;
$$ LANGUAGE plpgsql;
```

**2. Backend Service (Token Generation & Refresh):**

```typescript
// api/src/auth/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import * as bcrypt from 'bcrypt';
import * as crypto from 'crypto';
import { RefreshToken } from './entities/refresh-token.entity';
import { SupabaseService } from '../supabase/supabase.service';

@Injectable()
export class AuthService {
  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly supabaseService: SupabaseService,
    @InjectRepository(RefreshToken)
    private readonly refreshTokenRepo: Repository<RefreshToken>
  ) {}

  /**
   * Login: Generate access token + refresh token
   */
  async login(
    user: any,
    deviceInfo?: { userAgent: string; ip: string }
  ): Promise<{ accessToken: string; refreshToken: string }> {
    
    // 1. Generate Access Token (15 minutes)
    const accessToken = this.generateAccessToken(user);

    // 2. Generate Refresh Token (7 days)
    const refreshTokenString = this.generateRefreshTokenString();
    
    // 3. Hash refresh token before storing (OWASP best practice)
    const tokenHash = await bcrypt.hash(refreshTokenString, 10);

    // 4. Store in database
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

    await this.refreshTokenRepo.save({
      user_id: user.id,
      token_hash: tokenHash,
      expires_at: expiresAt,
      ip_address: deviceInfo?.ip,
      user_agent: deviceInfo?.userAgent,
      device_info: {
        userAgent: deviceInfo?.userAgent,
        platform: this.extractPlatform(deviceInfo?.userAgent),
        browser: this.extractBrowser(deviceInfo?.userAgent)
      }
    });

    return {
      accessToken,
      refreshToken: refreshTokenString
    };
  }

  /**
   * Refresh Tokens (Silent Refresh)
   */
  async refreshTokens(
    refreshTokenString: string,
    deviceInfo?: { userAgent: string; ip: string }
  ): Promise<{ accessToken: string; refreshToken: string }> {

    // 1. Find all active refresh tokens for this token
    const tokens = await this.refreshTokenRepo.find({
      where: {
        is_revoked: false,
        expires_at: MoreThan(new Date())
      }
    });

    // 2. Verify hash (constant-time comparison)
    let validToken: RefreshToken | null = null;
    for (const token of tokens) {
      const isValid = await bcrypt.compare(refreshTokenString, token.token_hash);
      if (isValid) {
        validToken = token;
        break;
      }
    }

    if (!validToken) {
      throw new UnauthorizedException('Invalid or expired refresh token');
    }

    // 3. Check for token reuse (security breach detection)
    if (validToken.rotated_to) {
      // This token was already rotated - possible theft!
      await this.revokeAllUserTokens(validToken.user_id);
      throw new UnauthorizedException('Token reuse detected. All sessions revoked.');
    }

    // 4. Get fresh user data from database
    const supabase = this.supabaseService.getClient();
    const { data: user, error } = await supabase
      .from('user_permissions')
      .select('*')
      .eq('id', validToken.user_id)
      .single();

    if (error || !user || !user.is_active) {
      throw new UnauthorizedException('User not found or inactive');
    }

    // 5. Generate new tokens
    const newAccessToken = this.generateAccessToken(user);
    const newRefreshTokenString = this.generateRefreshTokenString();
    const newTokenHash = await bcrypt.hash(newRefreshTokenString, 10);

    // 6. Store new refresh token
    const newRefreshToken = await this.refreshTokenRepo.save({
      user_id: user.id,
      token_hash: newTokenHash,
      expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      ip_address: deviceInfo?.ip,
      user_agent: deviceInfo?.userAgent,
      device_info: {
        userAgent: deviceInfo?.userAgent
      }
    });

    // 7. Mark old token as rotated (not revoked, for audit trail)
    await this.refreshTokenRepo.update(validToken.id, {
      rotated_to: newRefreshToken.id
    });

    return {
      accessToken: newAccessToken,
      refreshToken: newRefreshTokenString
    };
  }

  /**
   * Revoke all tokens for a user (logout all devices)
   */
  private async revokeAllUserTokens(userId: string): Promise<void> {
    await this.refreshTokenRepo.update(
      { user_id: userId },
      {
        is_revoked: true,
        revoked_at: new Date()
      }
    );
  }

  /**
   * Generate Access Token (JWT)
   */
  private generateAccessToken(user: any): string {
    const payload = {
      sub: user.id,
      user_id: user.user_id || user.id,
      office_id: user.office_id,
      role: user.role,
      permissions: user.permissions
    };

    return this.jwtService.sign(payload, {
      secret: this.configService.get<string>('JWT_SECRET'),
      expiresIn: '15m'
    });
  }

  /**
   * Generate cryptographically secure refresh token
   */
  private generateRefreshTokenString(): string {
    return crypto.randomBytes(64).toString('base64url');
  }

  private extractPlatform(userAgent: string): string {
    // Simple platform detection
    if (!userAgent) return 'unknown';
    if (userAgent.includes('Windows')) return 'Windows';
    if (userAgent.includes('Mac')) return 'macOS';
    if (userAgent.includes('Linux')) return 'Linux';
    if (userAgent.includes('Android')) return 'Android';
    if (userAgent.includes('iOS')) return 'iOS';
    return 'unknown';
  }

  private extractBrowser(userAgent: string): string {
    if (!userAgent) return 'unknown';
    if (userAgent.includes('Chrome')) return 'Chrome';
    if (userAgent.includes('Firefox')) return 'Firefox';
    if (userAgent.includes('Safari')) return 'Safari';
    if (userAgent.includes('Edge')) return 'Edge';
    return 'unknown';
  }
}
```

**3. Auth Controller (Endpoints):**

```typescript
// api/src/auth/auth.controller.ts
import { Controller, Post, Body, Req, Res, UseGuards, Get } from '@nestjs/common';
import { Response, Request } from 'express';
import { AuthService } from './auth.service';
import { JwtAuthGuard } from './jwt-auth.guard';
import { Public } from './public.decorator';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Public()
  @Post('login')
  async login(
    @Body() dto: { phone: string; password: string },
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response
  ) {
    // Validate credentials
    const user = await this.authService.validateUser(dto.phone, dto.password);

    if (!user) {
      throw new UnauthorizedException('بيانات الدخول غير صحيحة');
    }

    // Generate tokens
    const { accessToken, refreshToken } = await this.authService.login(user, {
      userAgent: req.headers['user-agent'],
      ip: req.ip
    });

    // Set refresh token in HttpOnly cookie (OWASP best practice)
    res.cookie('refresh_token', refreshToken, {
      httpOnly: true,      // Cannot be accessed by JavaScript (prevents XSS)
      secure: process.env.NODE_ENV === 'production', // HTTPS only in production
      sameSite: 'strict',  // CSRF protection
      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      path: '/api/auth'    // Only sent to auth endpoints
    });

    return {
      success: true,
      accessToken,
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        role: user.role,
        office_id: user.office_id
      }
    };
  }

  @Public()
  @Post('refresh')
  async refresh(
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response
  ) {
    // Get refresh token from HttpOnly cookie
    const refreshToken = req.cookies['refresh_token'];

    if (!refreshToken) {
      throw new UnauthorizedException('No refresh token provided');
    }

    // Generate new tokens
    const { accessToken, refreshToken: newRefreshToken } = await this.authService.refreshTokens(
      refreshToken,
      {
        userAgent: req.headers['user-agent'],
        ip: req.ip
      }
    );

    // Set new refresh token in cookie (rotation)
    res.cookie('refresh_token', newRefreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000,
      path: '/api/auth'
    });

    return {
      success: true,
      accessToken
    };
  }

  @Post('logout')
  @UseGuards(JwtAuthGuard)
  async logout(
    @Req() req: any,
    @Res({ passthrough: true }) res: Response
  ) {
    // Revoke all refresh tokens for this user
    await this.authService.revokeAllUserTokens(req.user.id);

    // Clear cookie
    res.clearCookie('refresh_token', { path: '/api/auth' });

    return {
      success: true,
      message: 'تم تسجيل الخروج بنجاح'
    };
  }

  @Get('profile')
  @UseGuards(JwtAuthGuard)
  async getProfile(@Req() req: any) {
    return {
      user: req.user
    };
  }
}
```

**4. Frontend: Axios Interceptor (Silent Token Refresh):**

```typescript
// Web/src/lib/axios.ts
import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001',
  withCredentials: true, // CRITICAL: Send HttpOnly cookies
  timeout: 30000
});

// Track if refresh is in progress to avoid multiple simultaneous refreshes
let isRefreshing = false;
let refreshSubscribers: ((token: string) => void)[] = [];

/**
 * Subscribe to token refresh completion
 */
function subscribeTokenRefresh(callback: (token: string) => void) {
  refreshSubscribers.push(callback);
}

/**
 * Notify all subscribers when new token arrives
 */
function onTokenRefreshed(token: string) {
  refreshSubscribers.forEach(callback => callback(token));
  refreshSubscribers = [];
}

// Request Interceptor: Attach access token
api.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    const accessToken = localStorage.getItem('accessToken');
    
    if (accessToken && config.headers) {
      config.headers.Authorization = `Bearer ${accessToken}`;
    }

    return config;
  },
  (error) => Promise.reject(error)
);

// Response Interceptor: Handle 401 with silent refresh
api.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config as InternalAxiosRequestConfig & { _retry?: boolean };

    // Check if error is 401 and we haven't retried yet
    if (error.response?.status === 401 && !originalRequest._retry) {
      
      // Special case: If the failing request is /auth/refresh itself, don't retry
      if (originalRequest.url?.includes('/auth/refresh')) {
        // Refresh token is invalid, redirect to login
        localStorage.removeItem('accessToken');
        if (typeof window !== 'undefined') {
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }

      // If refresh is already in progress, queue this request
      if (isRefreshing) {
        return new Promise((resolve) => {
          subscribeTokenRefresh((token: string) => {
            if (originalRequest.headers) {
              originalRequest.headers.Authorization = `Bearer ${token}`;
            }
            resolve(api(originalRequest));
          });
        });
      }

      // Mark as retrying to prevent infinite loops
      originalRequest._retry = true;
      isRefreshing = true;

      try {
        // Attempt to refresh the token
        const { data } = await axios.post(
          `${process.env.NEXT_PUBLIC_API_URL}/api/auth/refresh`,
          {},
          { withCredentials: true } // Send HttpOnly cookie
        );

        const newAccessToken = data.accessToken;

        // Store new access token
        localStorage.setItem('accessToken', newAccessToken);

        // Update Authorization header for original request
        if (originalRequest.headers) {
          originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
        }

        // Notify all queued requests
        onTokenRefreshed(newAccessToken);

        isRefreshing = false;

        // Retry original request
        return api(originalRequest);

      } catch (refreshError) {
        // Refresh failed - user needs to login again
        isRefreshing = false;
        refreshSubscribers = [];

        localStorage.removeItem('accessToken');
        
        if (typeof window !== 'undefined') {
          window.location.href = '/login';
        }

        return Promise.reject(refreshError);
      }
    }

    // For other errors, just reject
    return Promise.reject(error);
  }
);

export default api;
```

**5. Frontend: Login Flow:**

```typescript
// Web/src/lib/api/auth.ts
import api from '../axios';

export const authApi = {
  login: async (phone: string, password: string) => {
    const { data } = await api.post('/api/auth/login', { phone, password });
    
    // Store access token in localStorage
    localStorage.setItem('accessToken', data.accessToken);
    
    return data;
  },

  logout: async () => {
    await api.post('/api/auth/logout');
    localStorage.removeItem('accessToken');
  },

  getProfile: async () => {
    const { data } = await api.get('/api/auth/profile');
    return data;
  }
};
```

```typescript
// Web/src/app/login/page.tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { authApi } from '@/lib/api/auth';
import { useAuthStore } from '@/store/authStore';

export default function LoginPage() {
  const [phone, setPhone] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const router = useRouter();
  const { setAuth } = useAuthStore();

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const data = await authApi.login(phone, password);
      
      // Update Zustand store
      setAuth(data.user, data.accessToken);

      // Redirect to dashboard
      router.push('/dashboard');
    } catch (err: any) {
      setError(err.response?.data?.message || 'فشل تسجيل الدخول');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-lg w-full max-w-md">
        <h2 className="text-2xl font-bold mb-6 text-center">تسجيل الدخول</h2>
        
        <form onSubmit={handleLogin} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-2">رقم الهاتف</label>
            <input
              type="tel"
              value={phone}
              onChange={(e) => setPhone(e.target.value)}
              className="w-full border rounded-lg px-4 py-2"
              placeholder="05xxxxxxxx"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">كلمة المرور</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full border rounded-lg px-4 py-2"
              required
            />
          </div>

          {error && (
            <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
              {error}
            </div>
          )}

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-blue-600 text-white py-3 rounded-lg font-semibold hover:bg-blue-700 disabled:bg-gray-400"
          >
            {loading ? 'جاري تسجيل الدخول...' : 'تسجيل الدخول'}
          </button>
        </form>
      </div>
    </div>
  );
}
```

---

### 4.3 معمارية Backend (NestJS Architecture)

#### 4.3.1 Module Structure

**النظرية (Theory - Why):**

NestJS يستخدم **Modular Architecture** لتحقيق:
1. **Separation of Concerns:** كل module مستقل
2. **Dependency Injection:** سهولة الاختبار والصيانة
3. **Code Reusability:** Shared modules
4. **Scalability:** سهولة التحويل لـ Microservices

**المثال (Example - What):**

```
PropertiesModule
├── PropertiesController (HTTP Layer)
├── PropertiesService (Business Logic)
├── PropertiesRepository (Data Access - optional)
└── DTOs (Data Transfer Objects)
```

**المساعدة/الكود (Aid/Code - How):**

**Module Definition:**

```typescript
// api/src/properties/properties.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PropertiesController } from './properties.controller';
import { PropertiesService } from './properties.service';
import { Property } from './entities/property.entity';
import { SupabaseModule } from '../supabase/supabase.module';
import { CacheModule } from '@nestjs/cache-manager';
import * as redisStore from 'cache-manager-redis-store';

@Module({
  imports: [
    TypeOrmModule.forFeature([Property]),
    SupabaseModule,
    CacheModule.register({
      store: redisStore,
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT) || 6379,
      ttl: 300 // 5 minutes default TTL
    })
  ],
  controllers: [PropertiesController],
  providers: [PropertiesService],
  exports: [PropertiesService] // Allow other modules to use PropertiesService
})
export class PropertiesModule {}
```

---

### 4.4 تصميم قاعدة البيانات (Database Design)

#### 4.4.1 Performance-Critical Indexes

**النظرية (Theory - Why):**

Indexes تُحسّن أداء الـ queries بشكل كبير ولكن:
- **Pros:** Query speed improvement (10x-1000x faster)
- **Cons:** Slower writes, increased storage

**القاعدة:** Index كل foreign key، كل column في WHERE clause المتكررة، وكل column في ORDER BY.

**المساعدة/الكود (Aid/Code - How):**

**Top 5 Most Critical Indexes:**

```sql
-- ✅ Index 1: Properties by office (most frequent query)
-- Used in: Every properties list/search query
CREATE INDEX idx_properties_office_active 
ON properties(office_id, deleted_at) 
WHERE deleted_at IS NULL;

-- Performance impact: ~100x faster
-- Query example: SELECT * FROM properties WHERE office_id = ? AND deleted_at IS NULL

-- ✅ Index 2: Properties search (full-text search)
CREATE INDEX idx_properties_search 
ON properties USING gin(to_tsvector('arabic', title || ' ' || COALESCE(description, '')));

-- Usage:
SELECT * FROM properties 
WHERE to_tsvector('arabic', title || ' ' || description) @@ plainto_tsquery('arabic', 'فيلا رياض');

-- ✅ Index 3: Customers by office with phone lookup
CREATE INDEX idx_customers_office_phone 
ON customers(office_id, phone);

-- Performance impact: ~50x faster for phone searches
-- Query example: SELECT * FROM customers WHERE office_id = ? AND phone = ?

-- ✅ Index 4: Rental payments due date (for notifications)
CREATE INDEX idx_payments_due 
ON rental_payments(office_id, due_date, status) 
WHERE status IN ('pending', 'overdue');

-- Usage: Find overdue payments
SELECT * FROM rental_payments 
WHERE office_id = ? 
  AND due_date < NOW() 
  AND status = 'pending';

-- ✅ Index 5: Appointments by date range (calendar queries)
CREATE INDEX idx_appointments_schedule 
ON appointments(office_id, scheduled_at) 
WHERE deleted_at IS NULL;

-- Usage: Get appointments for a specific week
SELECT * FROM appointments 
WHERE office_id = ? 
  AND scheduled_at BETWEEN ? AND ?
  AND deleted_at IS NULL
ORDER BY scheduled_at;
```

**Composite Index Strategy:**

```sql
-- Rule: Order matters! Put most selective column first
-- ✅ GOOD: office_id first (high selectivity)
CREATE INDEX idx_contracts_office_status ON rental_contracts(office_id, status);

-- ❌ BAD: status first (low selectivity - only 3-4 values)
CREATE INDEX idx_contracts_status_office ON rental_contracts(status, office_id);

-- Partial Index for active records only (saves space)
CREATE INDEX idx_users_active_office 
ON user_permissions(office_id, role) 
WHERE is_active = true AND deleted_at IS NULL;
```

---

### 4.5 محرك التحليلات الفورية (Real-Time Analytics Engine)

#### 4.5.1 حل الملاحظات #1, #2, #7: Dashboard Analytics Architecture

**النظرية (Theory - Why):**

**المشكلة:** "البيانات التحليلية في الداشبورد بيانات وهمية"

**السبب الجذري:**
الـ Dashboard يستخدم mock data بدلاً من بيانات حقيقية من قاعدة البيانات.

**الحل المعماري:**
استخدام **Materialized Views + Incremental Refresh** لتحقيق:
1. **Performance:** Pre-computed aggregations
2. **Freshness:** Refresh every 5 minutes via cron
3. **Flexibility:** Dynamic filters via QueryBuilder

**OLTP vs. OLAP:**
- **OLTP (Online Transaction Processing):** Optimized for writes (properties, contracts)
- **OLAP (Online Analytical Processing):** Optimized for reads (dashboards, reports)

**الحل:** Hybrid approach - OLTP tables + OLAP materialized views

**المثال (Example - What):**

**Dashboard Metrics:**
1. Properties by Status (for sale, rented, available)
2. Monthly Revenue (last 12 months)
3. Active Contracts count
4. Pending Payments count
5. Maintenance Requests by Status

**المساعدة/الكود (Aid/Code - How):**

**1. Materialized Views (Pre-computed Aggregations):**

```sql
-- Materialized View 1: Properties by Status per Office
CREATE MATERIALIZED VIEW mv_properties_by_status AS
SELECT 
  office_id,
  status,
  COUNT(*) as property_count,
  AVG(price) as avg_price,
  SUM(CASE WHEN listing_type = 'sale' THEN 1 ELSE 0 END) as for_sale_count,
  SUM(CASE WHEN listing_type = 'rent' THEN 1 ELSE 0 END) as for_rent_count,
  NOW() as last_updated
FROM properties
WHERE deleted_at IS NULL
GROUP BY office_id, status;

-- Index for fast lookups
CREATE UNIQUE INDEX idx_mv_props_office_status 
ON mv_properties_by_status(office_id, status);

-- Refresh function (call every 5 minutes)
CREATE OR REPLACE FUNCTION refresh_properties_stats()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_properties_by_status;
END;
$$ LANGUAGE plpgsql;

-- Materialized View 2: Monthly Revenue per Office
CREATE MATERIALIZED VIEW mv_monthly_revenue AS
SELECT 
  office_id,
  DATE_TRUNC('month', payment_date) as month,
  SUM(amount) as total_revenue,
  COUNT(*) as payment_count,
  AVG(amount) as avg_payment,
  NOW() as last_updated
FROM rental_payments
WHERE status = 'paid'
  AND payment_date IS NOT NULL
GROUP BY office_id, DATE_TRUNC('month', payment_date);

CREATE UNIQUE INDEX idx_mv_revenue_office_month 
ON mv_monthly_revenue(office_id, month);

-- Materialized View 3: Contract Statistics
CREATE MATERIALIZED VIEW mv_contract_stats AS
SELECT 
  office_id,
  status,
  COUNT(*) as contract_count,
  SUM(monthly_rent) as total_monthly_rent,
  AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / 86400) as avg_duration_days,
  NOW() as last_updated
FROM rental_contracts
WHERE deleted_at IS NULL
GROUP BY office_id, status;

CREATE UNIQUE INDEX idx_mv_contracts_office_status 
ON mv_contract_stats(office_id, status);
```

**2. Backend Service (Analytics with Caching):**

```typescript
// api/src/analytics/analytics.service.ts
import { Injectable, Inject } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';
import { SupabaseService } from '../supabase/supabase.service';

@Injectable()
export class AnalyticsService {
  constructor(
    private readonly supabaseService: SupabaseService,
    @Inject(CACHE_MANAGER) private cacheManager: Cache
  ) {}

  /**
   * Get Dashboard Metrics
   * حل الملاحظة #1: استخدام بيانات حقيقية من قاعدة البيانات
   */
  async getDashboard(officeId: string): Promise<any> {
    // Try cache first (5 minute TTL)
    const cacheKey = `dashboard:${officeId}`;
    const cached = await this.cacheManager.get(cacheKey);
    
    if (cached) {
      return cached;
    }

    const supabase = this.supabaseService.getClient();

    // Run all queries in parallel for performance
    const [
      propertiesStats,
      revenueStats,
      contractsStats,
      paymentsStats,
      maintenanceStats
    ] = await Promise.all([
      // 1. Properties by Status (from materialized view)
      supabase
        .from('mv_properties_by_status')
        .select('*')
        .eq('office_id', officeId),

      // 2. Monthly Revenue (last 12 months)
      supabase
        .from('mv_monthly_revenue')
        .select('*')
        .eq('office_id', officeId)
        .gte('month', new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString())
        .order('month', { ascending: true }),

      // 3. Contracts Stats
      supabase
        .from('mv_contract_stats')
        .select('*')
        .eq('office_id', officeId),

      // 4. Pending Payments
      supabase
        .from('rental_payments')
        .select('*', { count: 'exact', head: true })
        .eq('office_id', officeId)
        .eq('status', 'pending')
        .lte('due_date', new Date().toISOString()),

      // 5. Maintenance Requests by Status
      supabase
        .rpc('get_maintenance_by_status', { p_office_id: officeId })
    ]);

    const dashboard = {
      properties: {
        total: propertiesStats.data?.reduce((sum, s) => sum + s.property_count, 0) || 0,
        byStatus: propertiesStats.data || [],
        forSale: propertiesStats.data?.reduce((sum, s) => sum + s.for_sale_count, 0) || 0,
        forRent: propertiesStats.data?.reduce((sum, s) => sum + s.for_rent_count, 0) || 0
      },
      revenue: {
        lastMonth: revenueStats.data?.[revenueStats.data.length - 1]?.total_revenue || 0,
        last12Months: revenueStats.data || [],
        total: revenueStats.data?.reduce((sum, r) => sum + parseFloat(r.total_revenue), 0) || 0
      },
      contracts: {
        total: contractsStats.data?.reduce((sum, c) => sum + c.contract_count, 0) || 0,
        active: contractsStats.data?.find(c => c.status === 'active')?.contract_count || 0,
        byStatus: contractsStats.data || []
      },
      payments: {
        pending: paymentsStats.count || 0
      },
      maintenance: {
        byStatus: maintenanceStats.data || []
      },
      lastUpdated: new Date().toISOString()
    };

    // Cache for 5 minutes
    await this.cacheManager.set(cacheKey, dashboard, 300);

    return dashboard;
  }

  /**
   * حل الملاحظة #2: Dynamic Analytics with Filters
   */
  async getAdvancedAnalytics(
    officeId: string,
    filters: {
      module: 'properties' | 'contracts' | 'customers' | 'revenue';
      groupBy?: string; // 'city', 'type', 'month', 'status'
      dateRange?: { from: string; to: string };
      customFields?: string[];
    }
  ): Promise<any> {
    const supabase = this.supabaseService.getClient();

    switch (filters.module) {
      case 'properties':
        return this.getPropertiesAnalytics(officeId, filters);
      
      case 'contracts':
        return this.getContractsAnalytics(officeId, filters);
      
      case 'revenue':
        return this.getRevenueAnalytics(officeId, filters);
      
      default:
        throw new BadRequestException('Invalid module');
    }
  }

  /**
   * Dynamic Properties Analytics
   */
  private async getPropertiesAnalytics(
    officeId: string,
    filters: any
  ): Promise<any> {
    const supabase = this.supabaseService.getClient();

    // Build dynamic query using Supabase
    let query = supabase
      .from('properties')
      .select('*')
      .eq('office_id', officeId)
      .is('deleted_at', null);

    // Apply date range filter
    if (filters.dateRange) {
      query = query
        .gte('created_at', filters.dateRange.from)
        .lte('created_at', filters.dateRange.to);
    }

    const { data, error } = await query;

    if (error) throw error;

    // Group by dynamically
    if (filters.groupBy) {
      return this.groupByField(data, filters.groupBy);
    }

    return data;
  }

  /**
   * Helper: Group data by field
   */
  private groupByField(data: any[], field: string): any {
    const grouped = data.reduce((acc, item) => {
      const key = item[field] || 'Unknown';
      if (!acc[key]) {
        acc[key] = {
          count: 0,
          items: []
        };
      }
      acc[key].count++;
      acc[key].items.push(item);
      return acc;
    }, {});

    return Object.keys(grouped).map(key => ({
      [field]: key,
      count: grouped[key].count,
      percentage: (grouped[key].count / data.length) * 100
    }));
  }

  /**
   * حل الملاحظة #7: Market Intelligence Integration
   */
  async getMarketIntelligence(officeId: string, city: string): Promise<any> {
    const supabase = this.supabaseService.getClient();

    // 1. Average price per sqm in the city
    const { data: avgPriceData } = await supabase
      .rpc('get_avg_price_per_sqm', {
        p_office_id: officeId,
        p_city: city
      });

    // 2. Vacancy rate
    const { data: vacancyData } = await supabase
      .rpc('get_vacancy_rate', {
        p_office_id: officeId,
        p_city: city
      });

    // 3. Average time to rent
    const { data: timeToRentData } = await supabase
      .rpc('get_avg_time_to_rent', {
        p_office_id: officeId,
        p_city: city
      });

    return {
      city,
      avgPricePerSqm: avgPriceData,
      vacancyRate: vacancyData,
      avgTimeToRent: timeToRentData,
      insights: this.generateMarketInsights(avgPriceData, vacancyData, timeToRentData)
    };
  }

  private generateMarketInsights(avgPrice: any, vacancy: any, timeToRent: any): string[] {
    const insights = [];

    if (vacancy > 0.15) {
      insights.push('السوق لديه نسبة شغور عالية - فرصة للمستأجرين للتفاوض');
    }

    if (timeToRent > 45) {
      insights.push('متوسط وقت التأجير طويل - قد تحتاج إلى تحسين التسويق');
    }

    if (avgPrice < 2500) {
      insights.push('الأسعار منخفضة نسبياً - فرصة استثمارية جيدة');
    }

    return insights;
  }
}
```

**3. SQL Stored Procedures (للتحليلات المعقدة):**

```sql
-- Stored Procedure: Average Price per Square Meter
CREATE OR REPLACE FUNCTION get_avg_price_per_sqm(
  p_office_id UUID,
  p_city VARCHAR
)
RETURNS TABLE (
  property_type VARCHAR,
  avg_price_per_sqm DECIMAL,
  sample_size INT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.property_type,
    AVG(p.price / NULLIF(p.area, 0)) as avg_price_per_sqm,
    COUNT(*)::INT as sample_size
  FROM properties p
  WHERE p.office_id = p_office_id
    AND p.city = p_city
    AND p.area > 0
    AND p.price > 0
    AND p.deleted_at IS NULL
  GROUP BY p.property_type;
END;
$$ LANGUAGE plpgsql;

-- Stored Procedure: Vacancy Rate
CREATE OR REPLACE FUNCTION get_vacancy_rate(
  p_office_id UUID,
  p_city VARCHAR
)
RETURNS DECIMAL AS $$
DECLARE
  total_properties INT;
  vacant_properties INT;
BEGIN
  SELECT COUNT(*) INTO total_properties
  FROM properties
  WHERE office_id = p_office_id
    AND city = p_city
    AND listing_type = 'rent'
    AND deleted_at IS NULL;

  SELECT COUNT(*) INTO vacant_properties
  FROM properties
  WHERE office_id = p_office_id
    AND city = p_city
    AND listing_type = 'rent'
    AND status = 'available'
    AND deleted_at IS NULL;

  IF total_properties = 0 THEN
    RETURN 0;
  END IF;

  RETURN (vacant_properties::DECIMAL / total_properties);
END;
$$ LANGUAGE plpgsql;

-- Stored Procedure: Average Time to Rent
CREATE OR REPLACE FUNCTION get_avg_time_to_rent(
  p_office_id UUID,
  p_city VARCHAR
)
RETURNS DECIMAL AS $$
BEGIN
  RETURN (
    SELECT AVG(EXTRACT(EPOCH FROM (rc.start_date - p.created_at)) / 86400)
    FROM rental_contracts rc
    JOIN properties p ON rc.property_id = p.id
    WHERE p.office_id = p_office_id
      AND p.city = p_city
      AND rc.created_at >= NOW() - INTERVAL '12 months'
      AND rc.deleted_at IS NULL
  );
END;
$$ LANGUAGE plpgsql;
```

**4. Frontend: Dashboard Component:**

```typescript
// Web/src/app/dashboard/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { analyticsApi } from '@/lib/api/analytics';
import { useAuthStore } from '@/store/authStore';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

export default function DashboardPage() {
  const [dashboard, setDashboard] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const user = useAuthStore(state => state.user);

  useEffect(() => {
    fetchDashboard();
  }, []);

  const fetchDashboard = async () => {
    try {
      const data = await analyticsApi.getDashboard();
      setDashboard(data);
    } catch (error) {
      console.error('Error fetching dashboard:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return <div className="p-6">جاري تحميل البيانات...</div>;
  }

  return (
    <div className="p-6 space-y-6">
      <h1 className="text-3xl font-bold">لوحة التحكم</h1>

      {/* KPI Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <div className="bg-white border rounded-lg p-6">
          <h3 className="text-sm text-gray-600 mb-2">إجمالي العقارات</h3>
          <p className="text-3xl font-bold text-blue-600">{dashboard.properties.total}</p>
          <p className="text-xs text-gray-500 mt-1">
            {dashboard.properties.forSale} للبيع • {dashboard.properties.forRent} للإيجار
          </p>
        </div>

        <div className="bg-white border rounded-lg p-6">
          <h3 className="text-sm text-gray-600 mb-2">الإيرادات الشهرية</h3>
          <p className="text-3xl font-bold text-green-600">
            {dashboard.revenue.lastMonth.toLocaleString()} ريال
          </p>
          <p className="text-xs text-gray-500 mt-1">الشهر الحالي</p>
        </div>

        <div className="bg-white border rounded-lg p-6">
          <h3 className="text-sm text-gray-600 mb-2">العقود النشطة</h3>
          <p className="text-3xl font-bold text-purple-600">{dashboard.contracts.active}</p>
          <p className="text-xs text-gray-500 mt-1">من أصل {dashboard.contracts.total} عقد</p>
        </div>

        <div className="bg-white border rounded-lg p-6">
          <h3 className="text-sm text-gray-600 mb-2">المدفوعات المعلقة</h3>
          <p className="text-3xl font-bold text-orange-600">{dashboard.payments.pending}</p>
          <p className="text-xs text-gray-500 mt-1">تحتاج متابعة</p>
        </div>
      </div>

      {/* Revenue Chart */}
      <div className="bg-white border rounded-lg p-6">
        <h2 className="text-xl font-semibold mb-4">الإيرادات - آخر 12 شهر</h2>
        <ResponsiveContainer width="100%" height={300}>
          <BarChart data={dashboard.revenue.last12Months}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis 
              dataKey="month" 
              tickFormatter={(value) => new Date(value).toLocaleDateString('ar-SA', { month: 'short' })}
            />
            <YAxis />
            <Tooltip 
              formatter={(value) => `${value.toLocaleString()} ريال`}
              labelFormatter={(label) => new Date(label).toLocaleDateString('ar-SA', { month: 'long', year: 'numeric' })}
            />
            <Legend />
            <Bar dataKey="total_revenue" fill="#3b82f6" name="الإيرادات" />
          </BarChart>
        </ResponsiveContainer>
      </div>

      {/* Properties by Status */}
      <div className="bg-white border rounded-lg p-6">
        <h2 className="text-xl font-semibold mb-4">العقارات حسب الحالة</h2>
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          {dashboard.properties.byStatus.map((status: any) => (
            <div key={status.status} className="border rounded-lg p-4 text-center">
              <p className="text-2xl font-bold text-blue-600">{status.property_count}</p>
              <p className="text-sm text-gray-600 mt-1">{status.status}</p>
            </div>
          ))}
        </div>
      </div>

      <p className="text-xs text-gray-500 text-center">
        آخر تحديث: {new Date(dashboard.lastUpdated).toLocaleString('ar-SA')}
      </p>
    </div>
  );
}
```

---

### 4.6 الأداء وقابلية التوسع (Performance & Scalability)

#### 4.6.1 Redis Caching Strategy

**النظرية (Theory - Why):**

**Caching Layers:**
1. **Client-side:** Browser cache, React Query
2. **CDN:** CloudFlare for static assets
3. **Application:** Redis for API responses
4. **Database:** PostgreSQL query cache

**Redis Key Strategy:**
- **Pattern:** `{module}:{identifier}:{params}`
- **TTL:** Based on data volatility

**المساعدة/الكود (Aid/Code - How):**

**Redis Key Patterns:**

```typescript
// Cache Keys Convention
const CACHE_KEYS = {
  // Dashboard: 5 min TTL
  dashboard: (officeId: string) => `dashboard:${officeId}`,
  
  // Properties list: 1 min TTL (frequently updated)
  propertiesList: (officeId: string, page: number, filters: string) => 
    `properties:${officeId}:p${page}:${filters}`,
  
  // Property detail: 10 min TTL
  propertyDetail: (officeId: string, propertyId: string) => 
    `property:${officeId}:${propertyId}`,
  
  // Analytics: 5 min TTL
  analytics: (officeId: string, type: string, date: string) => 
    `analytics:${officeId}:${type}:${date}`,
  
  // User permissions: 30 min TTL (rarely changes)
  userPermissions: (userId: string) => 
    `user:${userId}:permissions`
};

// Cache Invalidation Patterns
const CACHE_INVALIDATE = {
  // When property is created/updated/deleted
  onPropertyChange: (officeId: string) => [
    `dashboard:${officeId}`,
    `properties:${officeId}:*`,
    `analytics:${officeId}:properties:*`
  ],
  
  // When payment is recorded
  onPaymentChange: (officeId: string) => [
    `dashboard:${officeId}`,
    `analytics:${officeId}:revenue:*`,
    `analytics:${officeId}:payments:*`
  ]
};
```

**Caching Service:**

```typescript
// api/src/common/services/cache.service.ts
import { Injectable, Inject } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';

@Injectable()
export class CacheService {
  constructor(
    @Inject(CACHE_MANAGER) private cacheManager: Cache
  ) {}

  /**
   * Get from cache or execute function
   */
  async getOrSet<T>(
    key: string,
    fn: () => Promise<T>,
    ttl: number = 300
  ): Promise<T> {
    // Try cache first
    const cached = await this.cacheManager.get<T>(key);
    if (cached) {
      return cached;
    }

    // Execute function
    const result = await fn();

    // Store in cache
    await this.cacheManager.set(key, result, ttl);

    return result;
  }

  /**
   * Invalidate cache by pattern
   */
  async invalidatePattern(pattern: string): Promise<void> {
    const keys = await this.cacheManager.store.keys(pattern);
    
    for (const key of keys) {
      await this.cacheManager.del(key);
    }
  }

  /**
   * Invalidate multiple keys
   */
  async invalidateKeys(keys: string[]): Promise<void> {
    for (const key of keys) {
      await this.cacheManager.del(key);
    }
  }
}
```

**Usage in Service:**

```typescript
// api/src/properties/properties.service.ts
import { Injectable } from '@nestjs/common';
import { CacheService } from '../common/services/cache.service';

@Injectable()
export class PropertiesService {
  constructor(
    private readonly cacheService: CacheService,
    private readonly supabaseService: SupabaseService
  ) {}

  async findAll(officeId: string, filters: any): Promise<any> {
    const cacheKey = CACHE_KEYS.propertiesList(
      officeId,
      filters.page || 1,
      JSON.stringify(filters)
    );

    return this.cacheService.getOrSet(
      cacheKey,
      async () => {
        // Actual database query
        const supabase = this.supabaseService.getClient();
        const { data } = await supabase
          .from('properties')
          .select('*')
          .eq('office_id', officeId)
          .is('deleted_at', null);
        
        return data;
      },
      60 // 1 minute TTL
    );
  }

  async create(officeId: string, userId: string, dto: CreatePropertyDto): Promise<any> {
    // Create property
    const property = await this.actuallyCreateProperty(officeId, userId, dto);

    // Invalidate related caches
    await this.cacheService.invalidateKeys(
      CACHE_INVALIDATE.onPropertyChange(officeId)
    );

    return property;
  }
}
```

---

### 4.7 معمارية واجهة المستخدم (Frontend Architecture)

#### 4.7.1 حل الملاحظة #15, #16, #17, #20, #21: Settings Module

**النظرية (Theory - Why):**

**المشكلة:** "في الاعدادات في المظهر يجب توفيرها، الإشعارات، الموظفين لا تعمل"

**الحل المعماري:**
استخدام **Feature-Based Folder Structure** مع **Mobile-First Design**:

1. **Modularity:** كل feature في folder منفصل
2. **Reusability:** Shared components
3. **Scalability:** سهولة إضافة features جديدة

**المساعدة/الكود (Aid/Code - How):**

**Settings Module Structure:**

```
Web/src/app/dashboard/settings/
├── layout.tsx                    # Settings layout with sidebar
├── page.tsx                      # Overview/Profile page
├── appearance/
│   └── page.tsx                  # حل الملاحظة #15
├── notifications/
│   └── page.tsx                  # حل الملاحظة #16
├── staff/
│   └── page.tsx                  # حل الملاحظة #17
├── integrations/
│   └── page.tsx                  # حل الملاحظة #21
├── security/
│   └── page.tsx
└── components/
    ├── SettingsSidebar.tsx       # حل الملاحظة #20 (responsive)
    └── SettingsCard.tsx
```

**1. Settings Layout (with Responsive Sidebar):**

```typescript
// Web/src/app/dashboard/settings/layout.tsx
'use client';

import { useState } from 'react';
import { usePathname } from 'next/navigation';
import Link from 'next/link';
import { 
  Palette, Bell, Users, Link as LinkIcon, 
  Shield, ChevronLeft, Menu, X 
} from 'lucide-react';

const settingsNav = [
  { href: '/dashboard/settings', label: 'الملف الشخصي', icon: Users },
  { href: '/dashboard/settings/appearance', label: 'المظهر', icon: Palette },
  { href: '/dashboard/settings/notifications', label: 'الإشعارات', icon: Bell },
  { href: '/dashboard/settings/staff', label: 'الموظفين', icon: Users },
  { href: '/dashboard/settings/integrations', label: 'التكاملات', icon: LinkIcon },
  { href: '/dashboard/settings/security', label: 'الأمان', icon: Shield }
];

export default function SettingsLayout({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();
  const [sidebarOpen, setSidebarOpen] = useState(false);

  return (
    <div className="flex h-screen bg-gray-50">
      {/* Mobile Sidebar Overlay */}
      {sidebarOpen && (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 z-40 lg:hidden"
          onClick={() => setSidebarOpen(false)}
        />
      )}

      {/* Sidebar - حل الملاحظة #20: Responsive */}
      <aside className={`
        fixed lg:static inset-y-0 right-0 z-50
        w-64 bg-white border-l border-gray-200
        transition-transform duration-300 ease-in-out
        lg:translate-x-0
        ${sidebarOpen ? 'translate-x-0' : 'translate-x-full'}
      `}>
        <div className="p-6 flex items-center justify-between border-b">
          <h2 className="text-xl font-bold">الإعدادات</h2>
          <button
            onClick={() => setSidebarOpen(false)}
            className="lg:hidden p-2 hover:bg-gray-100 rounded-lg"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <nav className="p-4 space-y-1 overflow-y-auto h-[calc(100vh-80px)]">
          {settingsNav.map((item) => {
            const Icon = item.icon;
            const isActive = pathname === item.href;

            return (
              <Link
                key={item.href}
                href={item.href}
                onClick={() => setSidebarOpen(false)}
                className={`
                  flex items-center gap-3 px-4 py-3 rounded-lg transition
                  ${isActive 
                    ? 'bg-blue-50 text-blue-700 font-semibold' 
                    : 'text-gray-700 hover:bg-gray-100'
                  }
                `}
              >
                <Icon className="w-5 h-5" />
                <span>{item.label}</span>
                <ChevronLeft className="w-4 h-4 mr-auto" />
              </Link>
            );
          })}
        </nav>
      </aside>

      {/* Main Content */}
      <main className="flex-1 overflow-y-auto">
        {/* Mobile Header */}
        <div className="lg:hidden bg-white border-b p-4 flex items-center justify-between">
          <h1 className="text-xl font-bold">الإعدادات</h1>
          <button
            onClick={() => setSidebarOpen(true)}
            className="p-2 hover:bg-gray-100 rounded-lg"
          >
            <Menu className="w-6 h-6" />
          </button>
        </div>

        <div className="p-6">
          {children}
        </div>
      </main>
    </div>
  );
}
```

**2. Appearance Settings (حل الملاحظة #15):**

```typescript
// Web/src/app/dashboard/settings/appearance/page.tsx
'use client';

import { useState } from 'react';
import { useSettingsStore } from '@/store/settingsStore';
import { Sun, Moon, Monitor } from 'lucide-react';

export default function AppearanceSettings() {
  const { theme, setTheme, fontSize, setFontSize, language } = useSettingsStore();

  const themes = [
    { value: 'light', label: 'فاتح', icon: Sun },
    { value: 'dark', label: 'داكن', icon: Moon },
    { value: 'system', label: 'تلقائي', icon: Monitor }
  ];

  const fontSizes = [
    { value: 'small', label: 'صغير' },
    { value: 'medium', label: 'متوسط' },
    { value: 'large', label: 'كبير' }
  ];

  return (
    <div className="max-w-2xl space-y-6">
      <div>
        <h1 className="text-2xl font-bold mb-2">إعدادات المظهر</h1>
        <p className="text-gray-600">
          قم بتخصيص شكل التطبيق ليناسب تفضيلاتك
        </p>
      </div>

      {/* Theme Selection */}
      <div className="bg-white border rounded-lg p-6">
        <h2 className="text-lg font-semibold mb-4">الثيم (Theme)</h2>
        <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
          {themes.map((themeOption) => {
            const Icon = themeOption.icon;
            const isSelected = theme === themeOption.value;

            return (
              <button
                key={themeOption.value}
                onClick={() => setTheme(themeOption.value as any)}
                className={`
                  p-6 border-2 rounded-lg flex flex-col items-center gap-3 transition
                  ${isSelected 
                    ? 'border-blue-500 bg-blue-50' 
                    : 'border-gray-200 hover:border-blue-300'
                  }
                `}
              >
                <Icon className={`w-8 h-8 ${isSelected ? 'text-blue-600' : 'text-gray-600'}`} />
                <span className="font-medium">{themeOption.label}</span>
              </button>
            );
          })}
        </div>
      </div>

      {/* Font Size */}
      <div className="bg-white border rounded-lg p-6">
        <h2 className="text-lg font-semibold mb-4">حجم الخط</h2>
        <div className="flex gap-3">
          {fontSizes.map((size) => (
            <button
              key={size.value}
              onClick={() => setFontSize(size.value as any)}
              className={`
                px-6 py-3 border-2 rounded-lg transition
                ${fontSize === size.value 
                  ? 'border-blue-500 bg-blue-50 text-blue-700 font-semibold' 
                  : 'border-gray-200 hover:border-blue-300'
                }
              `}
            >
              {size.label}
            </button>
          ))}
        </div>
      </div>

      {/* Color Scheme */}
      <div className="bg-white border rounded-lg p-6">
        <h2 className="text-lg font-semibold mb-4">اللون الأساسي</h2>
        <div className="grid grid-cols-4 sm:grid-cols-8 gap-3">
          {['blue', 'green', 'purple', 'red', 'orange', 'pink', 'teal', 'indigo'].map((color) => (
            <button
              key={color}
              className={`
                w-12 h-12 rounded-full border-4 border-transparent
                hover:border-gray-300 transition
                bg-${color}-500
              `}
              onClick={() => {
                // Update primary color
                document.documentElement.style.setProperty('--primary-color', color);
              }}
            />
          ))}
        </div>
      </div>

      <button className="w-full sm:w-auto bg-blue-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-blue-700">
        حفظ التغييرات
      </button>
    </div>
  );
}
```

**3. Notifications Settings (حل الملاحظة #16):**

```typescript
// Web/src/app/dashboard/settings/notifications/page.tsx
'use client';

import { useState } from 'react';
import { Bell, Mail, MessageSquare, Smartphone } from 'lucide-react';

export default function NotificationsSettings() {
  const [settings, setSettings] = useState({
    email: {
      newLead: true,
      paymentDue: true,
      contractExpiring: true,
      maintenanceRequest: false
    },
    push: {
      newLead: true,
      paymentDue: true,
      contractExpiring: false,
      maintenanceRequest: true
    },
    whatsapp: {
      enabled: false,
      phoneNumber: '',
      newLead: false,
      paymentDue: true,
      contractExpiring: true,
      maintenanceRequest: false
    }
  });

  const notificationTypes = [
    { key: 'newLead', label: 'عميل جديد', description: 'عندما يتم إضافة عميل محتمل جديد' },
    { key: 'paymentDue', label: 'دفعة مستحقة', description: 'عندما يقترب موعد دفع الإيجار' },
    { key: 'contractExpiring', label: 'عقد ينتهي قريباً', description: 'قبل 30 يوم من انتهاء العقد' },
    { key: 'maintenanceRequest', label: 'طلب صيانة', description: 'عند إنشاء طلب صيانة جديد' }
  ];

  return (
    <div className="max-w-3xl space-y-6">
      <div>
        <h1 className="text-2xl font-bold mb-2">إعدادات الإشعارات</h1>
        <p className="text-gray-600">
          اختر كيفية تلقي الإشعارات الهامة
        </p>
      </div>

      {/* Email Notifications */}
      <div className="bg-white border rounded-lg p-6">
        <div className="flex items-center gap-3 mb-4">
          <Mail className="w-6 h-6 text-blue-600" />
          <h2 className="text-lg font-semibold">البريد الإلكتروني</h2>
        </div>
        <div className="space-y-3">
          {notificationTypes.map((type) => (
            <label key={type.key} className="flex items-start gap-3 p-3 hover:bg-gray-50 rounded-lg cursor-pointer">
              <input
                type="checkbox"
                checked={settings.email[type.key]}
                onChange={(e) => setSettings({
                  ...settings,
                  email: { ...settings.email, [type.key]: e.target.checked }
                })}
                className="mt-1 w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              />
              <div className="flex-1">
                <p className="font-medium">{type.label}</p>
                <p className="text-sm text-gray-600">{type.description}</p>
              </div>
            </label>
          ))}
        </div>
      </div>

      {/* Push Notifications */}
      <div className="bg-white border rounded-lg p-6">
        <div className="flex items-center gap-3 mb-4">
          <Bell className="w-6 h-6 text-green-600" />
          <h2 className="text-lg font-semibold">إشعارات التطبيق</h2>
        </div>
        <div className="space-y-3">
          {notificationTypes.map((type) => (
            <label key={type.key} className="flex items-start gap-3 p-3 hover:bg-gray-50 rounded-lg cursor-pointer">
              <input
                type="checkbox"
                checked={settings.push[type.key]}
                onChange={(e) => setSettings({
                  ...settings,
                  push: { ...settings.push, [type.key]: e.target.checked }
                })}
                className="mt-1 w-5 h-5 rounded border-gray-300 text-green-600 focus:ring-green-500"
              />
              <div className="flex-1">
                <p className="font-medium">{type.label}</p>
                <p className="text-sm text-gray-600">{type.description}</p>
              </div>
            </label>
          ))}
        </div>
      </div>

      {/* WhatsApp Notifications - حل الملاحظة #16 */}
      <div className="bg-white border rounded-lg p-6">
        <div className="flex items-center gap-3 mb-4">
          <MessageSquare className="w-6 h-6 text-emerald-600" />
          <h2 className="text-lg font-semibold">واتساب</h2>
          <span className="mr-auto text-sm font-medium px-3 py-1 bg-blue-100 text-blue-700 rounded-full">
            قيد التطوير
          </span>
        </div>
        
        <div className="mb-4 p-4 bg-amber-50 border border-amber-200 rounded-lg">
          <p className="text-sm text-amber-800">
            <strong>ملاحظة:</strong> لتفعيل إشعارات الواتساب، يجب ربط حساب WhatsApp Business API.
            يرجى الاتصال بمسؤول النظام للحصول على التعليمات التفصيلية.
          </p>
        </div>

        <label className="flex items-center gap-3 mb-4">
          <input
            type="checkbox"
            checked={settings.whatsapp.enabled}
            onChange={(e) => setSettings({
              ...settings,
              whatsapp: { ...settings.whatsapp, enabled: e.target.checked }
            })}
            className="w-5 h-5 rounded border-gray-300 text-emerald-600 focus:ring-emerald-500"
          />
          <span className="font-medium">تفعيل إشعارات الواتساب</span>
        </label>

        {settings.whatsapp.enabled && (
          <>
            <div className="mb-4">
              <label className="block text-sm font-medium mb-2">رقم الواتساب</label>
              <input
                type="tel"
                value={settings.whatsapp.phoneNumber}
                onChange={(e) => setSettings({
                  ...settings,
                  whatsapp: { ...settings.whatsapp, phoneNumber: e.target.value }
                })}
                placeholder="05xxxxxxxx"
                className="w-full border rounded-lg px-4 py-2"
              />
            </div>

            <div className="space-y-3">
              {notificationTypes.map((type) => (
                <label key={type.key} className="flex items-start gap-3 p-3 hover:bg-gray-50 rounded-lg cursor-pointer">
                  <input
                    type="checkbox"
                    checked={settings.whatsapp[type.key]}
                    onChange={(e) => setSettings({
                      ...settings,
                      whatsapp: { ...settings.whatsapp, [type.key]: e.target.checked }
                    })}
                    className="mt-1 w-5 h-5 rounded border-gray-300 text-emerald-600 focus:ring-emerald-500"
                  />
                  <div className="flex-1">
                    <p className="font-medium">{type.label}</p>
                    <p className="text-sm text-gray-600">{type.description}</p>
                  </div>
                </label>
              ))}
            </div>
          </>
        )}
      </div>

      <button className="w-full sm:w-auto bg-blue-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-blue-700">
        حفظ التغييرات
      </button>
    </div>
  );
}
```

**4. Zustand Store للإعدادات:**

```typescript
// Web/src/store/settingsStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface SettingsState {
  // Appearance
  theme: 'light' | 'dark' | 'system';
  fontSize: 'small' | 'medium' | 'large';
  language: 'ar' | 'en';
  
  // Notifications
  notificationsEnabled: boolean;
  emailNotifications: boolean;
  pushNotifications: boolean;
  whatsappNotifications: boolean;
  
  // Actions
  setTheme: (theme: 'light' | 'dark' | 'system') => void;
  setFontSize: (size: 'small' | 'medium' | 'large') => void;
  setLanguage: (lang: 'ar' | 'en') => void;
  toggleNotifications: () => void;
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set) => ({
      // Default values
      theme: 'light',
      fontSize: 'medium',
      language: 'ar',
      notificationsEnabled: true,
      emailNotifications: true,
      pushNotifications: true,
      whatsappNotifications: false,

      // Actions
      setTheme: (theme) => {
        set({ theme });
        
        // Apply theme to document
        if (theme === 'dark') {
          document.documentElement.classList.add('dark');
        } else if (theme === 'light') {
          document.documentElement.classList.remove('dark');
        } else {
          // System preference
          const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
          if (prefersDark) {
            document.documentElement.classList.add('dark');
          } else {
            document.documentElement.classList.remove('dark');
          }
        }
      },

      setFontSize: (fontSize) => {
        set({ fontSize });
        
        // Apply font size to document
        const fontSizeMap = {
          small: '14px',
          medium: '16px',
          large: '18px'
        };
        document.documentElement.style.fontSize = fontSizeMap[fontSize];
      },

      setLanguage: (language) => {
        set({ language });
        document.documentElement.lang = language;
        document.documentElement.dir = language === 'ar' ? 'rtl' : 'ltr';
      },

      toggleNotifications: () => set((state) => ({
        notificationsEnabled: !state.notificationsEnabled
      }))
    }),
    {
      name: 'settings-storage' // localStorage key
    }
  )
);
```

---

## الملاحظات الختامية للجزء الرابع

**ملخص النقاط الرئيسية:**

1. **Authentication & Security (حل الملاحظة #3):**
   - RefreshToken entity with rotation
   - Axios interceptor for silent refresh
   - HttpOnly cookies for security
   - Token reuse detection

2. **Database Performance:**
   - 5 critical indexes defined
   - Materialized views for analytics
   - Composite index strategy
   - Partial indexes for active records

3. **Real-Time Analytics (حل الملاحظات #1, #2, #7):**
   - Materialized views for pre-computed data
   - Redis caching (5-minute TTL)
   - Dynamic QueryBuilder for filters
   - Market intelligence integration

4. **Frontend Architecture (حل الملاحظات #13, #14, #15, #16, #17, #20, #21):**
   - Complete Settings module structure
   - Responsive sidebar (mobile-first)
   - Zustand store for settings
   - Favorites & Reports pages
   - WhatsApp notifications setup guide

5. **Performance & Scalability:**
   - Redis key patterns defined
   - Cache invalidation strategy
   - CacheService for reusability

---

**الخطوة التالية:**
هذا يكمل **PART IV: TECHNICAL VIEW**. النظام الآن لديه:
- ✅ Part I: Executive & Investor View
- ✅ Part II: Compliance & Legal View
- ✅ Part III: Operational View
- ✅ Part IV: Technical View

**الوثيقة جاهزة للمطورين!**

---

**تاريخ التحديث:** 19 نوفمبر 2025
**الإصدار:** 3.0 - Part IV
**الحالة:** مكتمل ✓

---

